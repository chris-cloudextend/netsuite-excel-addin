<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NetSuite Excel Formulas v1.1</title>
    <style>
        /* ============================================
           BRAND COLORS
           Primary: Blue Light #004fb6, Deep Dive #09235c, Chrome #a8b1ce
           Secondary: Anenome #0ae2c1, Tidal Wave #0079ff, Barnacle #d3d8e6, Bottlenose #6b7b9d
           ============================================ */
        :root {
            --blue-light: #004fb6;
            --deep-dive: #09235c;
            --chrome: #a8b1ce;
            --anenome: #0ae2c1;
            --tidal-wave: #0079ff;
            --barnacle: #d3d8e6;
            --bottlenose: #6b7b9d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, var(--deep-dive) 0%, var(--blue-light) 100%);
            color: #333;
            padding: 0;
            height: 100vh;
            overflow-y: auto;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 40px rgba(9, 35, 92, 0.3);
        }

        .header {
            background: linear-gradient(135deg, var(--deep-dive) 0%, var(--blue-light) 100%);
            color: white;
            padding: 24px 20px 20px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 22px;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .header p {
            font-size: 13px;
            opacity: 0.9;
            color: var(--chrome);
        }

        .header .version-badge {
            display: inline-block;
            background: var(--anenome);
            color: var(--deep-dive);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            margin-top: 8px;
            font-weight: 600;
        }

        /* Collapsible Section Styles */
        .collapsible-section {
            border: 1px solid var(--barnacle);
            border-radius: 12px;
            margin-bottom: 12px;
            overflow: hidden;
            background: white;
            transition: all 0.3s ease;
        }

        .collapsible-section:hover {
            box-shadow: 0 4px 12px rgba(9, 35, 92, 0.1);
        }

        .collapsible-header {
            background: linear-gradient(135deg, var(--barnacle) 0%, #e8ebf2 100%);
            padding: 14px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: background 0.2s;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, var(--chrome) 0%, var(--barnacle) 100%);
        }

        .collapsible-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--deep-dive);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .collapsible-header .icon {
            font-size: 18px;
        }

        .collapsible-header .chevron {
            width: 20px;
            height: 20px;
            fill: var(--bottlenose);
            transition: transform 0.3s ease;
        }

        .collapsible-section[open] .chevron {
            transform: rotate(180deg);
        }

        .collapsible-content {
            padding: 16px;
            background: white;
        }

        details.collapsible-section > summary {
            list-style: none;
        }
        details.collapsible-section > summary::-webkit-details-marker {
            display: none;
        }

        /* Help Section Special Styles */
        .help-section {
            border-color: var(--anenome);
        }

        .help-section .collapsible-header {
            background: linear-gradient(135deg, rgba(10, 226, 193, 0.15) 0%, rgba(10, 226, 193, 0.05) 100%);
        }

        .help-section .collapsible-header h3 {
            color: var(--deep-dive);
        }

        .help-tip {
            background: linear-gradient(135deg, rgba(10, 226, 193, 0.1) 0%, rgba(0, 121, 255, 0.05) 100%);
            border-left: 4px solid var(--anenome);
            padding: 12px 14px;
            border-radius: 0 8px 8px 0;
            margin: 12px 0;
        }

        .help-tip h4 {
            color: var(--deep-dive);
            font-size: 13px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .help-tip p {
            color: var(--bottlenose);
            font-size: 12px;
            line-height: 1.5;
        }

        .formula-example-box {
            background: var(--deep-dive);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
        }

        .formula-example-box code {
            color: var(--anenome);
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 12px;
            display: block;
            margin-bottom: 4px;
        }

        .formula-example-box .result {
            color: var(--chrome);
            font-size: 11px;
        }

        .dynamic-demo {
            background: white;
            border: 2px solid var(--tidal-wave);
            border-radius: 8px;
            padding: 14px;
            margin: 12px 0;
        }

        .dynamic-demo h5 {
            color: var(--tidal-wave);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        .excel-grid {
            display: grid;
            grid-template-columns: 40px repeat(3, 1fr);
            gap: 2px;
            font-size: 11px;
            margin: 10px 0;
        }

        .excel-cell {
            background: white;
            border: 1px solid var(--barnacle);
            padding: 6px 8px;
            text-align: center;
            min-height: 28px;
        }

        .excel-cell.header {
            background: var(--barnacle);
            font-weight: 600;
            color: var(--deep-dive);
        }

        .excel-cell.row-header {
            background: var(--barnacle);
            font-weight: 600;
            color: var(--deep-dive);
        }

        .excel-cell.formula {
            background: rgba(10, 226, 193, 0.1);
            color: var(--deep-dive);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 9px;
        }

        .excel-cell.formula.drag-indicator {
            background: rgba(10, 226, 193, 0.25);
            border: 1px dashed var(--seafoam);
            position: relative;
        }

        .excel-cell.value {
            background: rgba(0, 121, 255, 0.1);
            color: var(--blue-light);
            font-weight: 500;
        }

        .settings-btn {
            position: absolute;
            bottom: 12px;
            left: 12px;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: rgba(255, 255, 255, 0.8);
        }

        .settings-btn svg {
            width: 16px;
            height: 16px;
        }

        .settings-btn:hover {
            background: rgba(255, 255, 255, 0.22);
            transform: rotate(90deg);
            color: white;
        }

        .settings-btn:active {
            transform: rotate(90deg) scale(0.92);
        }

        .settings-btn svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        /* Help button in header */

        /* Guide Me Wizard */
        .guide-me-card {
            background: linear-gradient(135deg, var(--deep-dive) 0%, var(--blue-light) 100%);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .guide-me-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            pointer-events: none;
        }

        .guide-me-card h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .guide-me-card p {
            font-size: 13px;
            opacity: 0.9;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .guide-me-btn {
            background: var(--anenome);
            color: var(--deep-dive);
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .guide-me-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(10, 226, 193, 0.4);
        }

        .guide-me-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .guide-me-btn .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top-color: var(--deep-dive);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .guide-me-dismiss {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            color: white;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .guide-me-dismiss:hover {
            background: rgba(255,255,255,0.3);
        }

        .guide-me-progress {
            margin-top: 16px;
            font-size: 12px;
            opacity: 0.8;
        }

        .guide-me-hidden {
            display: none;
        }

        /* Pre-load Sheet Data Card */
        .preload-card {
            background: linear-gradient(135deg, #1a5a3e 0%, #2d8a5f 100%);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 16px;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .preload-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            pointer-events: none;
        }

        .preload-card h3 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preload-card p {
            font-size: 13px;
            opacity: 0.9;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .preload-card .instruction-box {
            background: rgba(255,255,255,0.15);
            border-radius: 10px;
            padding: 12px 14px;
            margin-bottom: 16px;
            font-size: 12px;
            line-height: 1.6;
        }

        .preload-card .instruction-box strong {
            color: #7dffb3;
        }

        .preload-btn {
            background: #7dffb3;
            color: #1a5a3e;
            border: none;
            padding: 14px 24px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
        }

        .preload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(125, 255, 179, 0.4);
        }

        .preload-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .preload-dismiss {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255,255,255,0.2);
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .preload-dismiss:hover {
            background: rgba(255,255,255,0.3);
        }

        .preload-hidden {
            display: none;
        }

        /* Pre-load Loading Overlay */
        .preload-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1a5a3e 0%, #2d8a5f 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            color: white;
            text-align: center;
            padding: 30px;
            animation: fadeIn 0.3s ease;
        }

        .preload-overlay .history-section {
            margin-top: 30px;
            padding: 20px 24px;
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            max-width: 340px;
            text-align: center;
            min-height: 100px;
        }

        .preload-overlay .history-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.6;
            margin-bottom: 8px;
        }

        .preload-overlay .history-year {
            font-size: 24px;
            font-weight: 700;
            color: #7dffb3;
            margin-bottom: 6px;
        }

        .preload-overlay .history-fact {
            font-size: 14px;
            color: #c8ffdb;
            transition: opacity 0.3s ease;
            line-height: 1.5;
        }

        /* Guide Me Choice Cards */
        .guide-choice {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 14px 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .guide-choice:hover {
            background: rgba(10, 226, 193, 0.25);
            border-color: var(--anenome);
            transform: translateX(4px);
        }
        
        .guide-choice-icon {
            font-size: 28px;
            margin-right: 14px;
            flex-shrink: 0;
        }
        
        .guide-choice-content {
            flex: 1;
        }
        
        .guide-choice-title {
            font-size: 14px;
            font-weight: 600;
            color: white;
            margin-bottom: 3px;
        }
        
        .guide-choice-desc {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.75);
            line-height: 1.4;
        }

        /* Guide Me Loading Overlay */
        .guide-me-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(9, 35, 92, 0.95);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 60px;
            color: white;
            padding-left: 30px;
            padding-right: 30px;
            text-align: center;
            animation: fadeIn 0.3s ease;
        }

        .guide-me-overlay h2 {
            font-size: 22px;
            margin-bottom: 16px;
        }

        .guide-me-overlay .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top-color: var(--anenome);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .guide-me-overlay .loading-subtitle {
            font-size: 13px;
            opacity: 0.7;
            margin-bottom: 24px;
            max-width: 300px;
        }

        .guide-me-overlay .progress-container {
            width: 100%;
            max-width: 320px;
            margin-bottom: 20px;
        }

        .guide-me-overlay .progress-bar-bg {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .guide-me-overlay .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--anenome), #06d6a0);
            border-radius: 4px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .guide-me-overlay .progress-text {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 8px;
        }

        .guide-me-overlay .loading-step {
            font-size: 14px;
            margin-top: 16px;
            color: var(--anenome);
            font-weight: 600;
            min-height: 40px;
        }

        .guide-me-overlay .loading-step-desc {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 6px;
            max-width: 280px;
        }

        .guide-me-overlay .tips-section {
            margin-top: 30px;
            padding: 20px 24px;
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            width: 100%;
            max-width: 380px;
            min-height: 80px;
        }

        .guide-me-overlay .tips-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.6;
            margin-bottom: 8px;
        }

        .guide-me-overlay .loading-tip {
            font-size: 14px;
            color: var(--anenome);
            transition: opacity 0.3s ease;
            min-height: 48px;
            font-weight: 500;
            line-height: 1.5;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Settings Modal */
        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(9, 35, 92, 0.7);
            z-index: 1000;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .settings-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-panel {
            background: white;
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(9, 35, 92, 0.4);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .settings-header {
            background: linear-gradient(135deg, var(--deep-dive) 0%, var(--blue-light) 100%);
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 16px 16px 0 0;
        }

        .settings-header h2 {
            font-size: 18px;
            font-weight: 600;
        }

        .settings-close {
            background: rgba(10, 226, 193, 0.3);
            border: none;
            color: white;
            font-size: 24px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-close:hover {
            background: var(--anenome);
        }

        .settings-content {
            padding: 20px;
        }

        .settings-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e5e7eb;
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .settings-section h3 {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-indicator.checking {
            background: #fef3c7;
            color: #92400e;
        }

        .status-indicator.connected {
            background: #d1fae5;
            color: #065f46;
        }

        .status-indicator.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-dot.checking { background: #f59e0b; animation: pulse 1s infinite; }
        .status-dot.connected { background: #10b981; }
        .status-dot.error { background: #ef4444; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .settings-input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 13px;
            margin-top: 8px;
            transition: border-color 0.2s;
        }

        .settings-input:focus {
            outline: none;
            border-color: #0066CC;
        }

        .settings-btn-action {
            background: var(--blue-light);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.2s;
        }

        .settings-btn-action:hover {
            background: var(--deep-dive);
            transform: translateY(-1px);
        }

        .settings-btn-action.secondary {
            background: var(--bottlenose);
        }

        .settings-btn-action.secondary:hover {
            background: var(--deep-dive);
        }

        .content {
            padding: 16px;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, var(--anenome) 0%, #06d6a0 100%);
            color: var(--deep-dive);
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .status-badge:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .status-badge.connected {
            background: linear-gradient(135deg, var(--anenome) 0%, #06d6a0 100%);
            color: var(--deep-dive);
        }

        .status-badge.disconnected {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%);
            color: white;
        }

        .status-badge.checking {
            background: linear-gradient(135deg, #ffd93d 0%, #ffb800 100%);
            color: var(--deep-dive);
        }

        .status-badge::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--deep-dive);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-badge.disconnected::before {
            background: white;
            animation: pulse-error 1s ease-in-out infinite;
        }

        .status-badge.checking::before {
            background: var(--deep-dive);
            animation: pulse-check 0.8s ease-in-out infinite;
        }

        @keyframes pulse-error {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        @keyframes pulse-check {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Primary action button */
        .btn-primary {
            background: linear-gradient(135deg, var(--blue-light) 0%, var(--tidal-wave) 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 79, 182, 0.35);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--bottlenose);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            margin-bottom: 8px;
        }

        .btn-secondary:hover {
            background: var(--deep-dive);
        }

        .btn-danger {
            background: #dc2626;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .btn-danger:hover {
            background: #b91c1c;
        }

        .refresh-status {
            font-size: 12px;
            color: var(--anenome);
            text-align: center;
            margin-top: 10px;
            min-height: 20px;
            font-weight: 500;
        }

        .btn-hint {
            font-size: 11px;
            color: var(--bottlenose);
            margin: 4px 0 12px;
            line-height: 1.4;
        }

        /* ============================================
           DATA MANAGEMENT REDESIGN
           ============================================ */
        .data-mgmt-section .collapsible-header {
            background: linear-gradient(135deg, var(--deep-dive) 0%, var(--blue-light) 100%);
        }
        
        .data-mgmt-section .collapsible-header h3 {
            color: white;
        }
        
        .data-mgmt-section .chevron {
            fill: white;
        }
        
        .data-mgmt-content {
            padding: 0 !important;
            background: #f8f9fc;
        }
        
        .data-section {
            padding: 16px;
            border-bottom: 1px solid var(--barnacle);
        }
        
        .data-section:last-child {
            border-bottom: none;
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .section-header h4 {
            font-size: 13px;
            font-weight: 600;
            color: var(--deep-dive);
            margin: 0;
        }
        
        /* Help Icon with Tooltip */
        .help-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background: var(--chrome);
            color: var(--deep-dive);
            border-radius: 50%;
            font-size: 11px;
            font-weight: 700;
            cursor: help;
            transition: all 0.2s;
            position: relative;
        }
        
        .help-icon:hover {
            background: var(--tidal-wave);
            color: white;
        }
        
        .help-icon.small {
            width: 14px;
            height: 14px;
            font-size: 9px;
        }
        
        /* Lightweight tooltip - smaller, lighter background, left-aligned */
        .help-icon[data-tip] {
            position: relative;
        }
        
        .help-icon[data-tip]:hover::after {
            content: attr(data-tip);
            position: fixed;
            top: auto;
            left: 16px;
            right: 16px;
            width: auto;
            max-width: calc(100vw - 32px);
            background: #f0f4f8;
            color: #1a365d;
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 400;
            white-space: normal;
            line-height: 1.4;
            text-align: left;
            z-index: 10000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            animation: tooltipFadeIn 0.15s ease-out;
            pointer-events: none;
            border: 1px solid #e2e8f0;
        }
        
        /* Position tooltip near the bottom of viewport for visibility */
        .help-icon[data-tip]:hover::after {
            bottom: 60px;
        }
        
        /* Arrow pointing up from tooltip */
        .help-icon[data-tip]:hover::before {
            display: none; /* Hide arrow since we're using fixed positioning */
        }
        
        @keyframes tooltipFadeIn {
            from {
                opacity: 0;
                transform: translateY(4px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Tooltip label styling */
        .tooltip-trigger {
            cursor: help;
            border-bottom: 1px dotted currentColor;
        }
        
        /* Load Data Button */
        .btn-load-data {
            width: 100%;
            background: linear-gradient(135deg, #1a5a3e 0%, #2d8a5f 100%);
            color: white;
            border: none;
            padding: 14px 20px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-load-data:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(26, 90, 62, 0.4);
        }
        
        .btn-load-data:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Checkbox Row */
        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            cursor: pointer;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid var(--barnacle);
        }
        
        .checkbox-row:hover {
            border-color: var(--tidal-wave);
        }
        
        .checkbox-row input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--tidal-wave);
            cursor: pointer;
        }
        
        .checkbox-label {
            font-size: 13px;
            color: var(--deep-dive);
            flex: 1;
        }
        
        /* Action Grid */
        .action-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .action-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 12px 8px;
            border: 1px solid var(--barnacle);
            border-radius: 8px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .action-btn:hover {
            border-color: var(--tidal-wave);
            box-shadow: 0 2px 8px rgba(0, 121, 255, 0.15);
        }
        
        .action-btn .action-icon {
            font-size: 20px;
        }
        
        .action-btn .action-text {
            font-size: 11px;
            font-weight: 600;
            color: var(--deep-dive);
        }
        
        .action-btn .help-icon {
            position: absolute;
            top: 4px;
            right: 4px;
        }
        
        .action-btn.primary {
            background: linear-gradient(135deg, rgba(0, 79, 182, 0.08) 0%, rgba(0, 121, 255, 0.08) 100%);
            border-color: var(--tidal-wave);
        }
        
        .action-btn.primary:hover {
            background: linear-gradient(135deg, rgba(0, 79, 182, 0.15) 0%, rgba(0, 121, 255, 0.15) 100%);
        }
        
        .action-btn.warning {
            background: linear-gradient(135deg, rgba(217, 119, 6, 0.08) 0%, rgba(245, 158, 11, 0.08) 100%);
            border-color: #d97706;
        }
        
        .action-btn.warning:hover {
            background: linear-gradient(135deg, rgba(217, 119, 6, 0.15) 0%, rgba(245, 158, 11, 0.15) 100%);
            border-color: #b45309;
        }
        
        .action-btn.danger {
            grid-column: span 2;
        }
        
        .action-btn.danger:hover {
            border-color: #dc2626;
            background: rgba(220, 38, 38, 0.05);
        }
        
        .preload-status {
            margin-top: 12px;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.5;
        }

        /* Filter Groups */
        .filter-group {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 8px;
            align-items: end;
            margin-bottom: 12px;
        }

        .filter-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--deep-dive);
            margin-bottom: 4px;
            grid-column: 1 / -1;
        }

        .filter-select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid var(--barnacle);
            border-radius: 8px;
            font-size: 13px;
            color: var(--deep-dive);
            background: white;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--tidal-wave);
        }

        .btn-filter {
            background: var(--tidal-wave);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-filter:hover {
            background: var(--blue-light);
        }

        /* Account Search Styles */
        .search-input {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid var(--barnacle);
            border-radius: 8px;
            font-size: 14px;
            color: var(--deep-dive);
            transition: all 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--anenome);
            box-shadow: 0 0 0 3px rgba(10, 226, 193, 0.15);
        }

        .search-input::placeholder {
            color: var(--chrome);
        }

        .search-hints {
            background: rgba(10, 226, 193, 0.08);
            border-radius: 8px;
            padding: 10px 12px;
            margin-top: 10px;
        }

        .search-hints code {
            background: var(--deep-dive);
            color: var(--anenome);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }

        /* Footer */
        .footer {
            background: var(--deep-dive);
            color: var(--chrome);
            padding: 16px;
            text-align: center;
            font-size: 12px;
        }

        .footer a {
            color: var(--anenome);
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        .formula-card {
            background: linear-gradient(135deg, rgba(168, 177, 206, 0.1) 0%, rgba(211, 216, 230, 0.3) 100%);
            border: 1px solid var(--barnacle);
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 14px;
            transition: all 0.3s ease;
        }

        .formula-card:hover {
            border-color: var(--tidal-wave);
            box-shadow: 0 4px 12px rgba(0, 79, 182, 0.1);
        }

        .formula-name {
            font-size: 16px;
            font-weight: 700;
            color: var(--blue-light);
            margin-bottom: 6px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
        }

        .formula-description {
            font-size: 12px;
            color: var(--bottlenose);
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .formula-syntax {
            background: var(--deep-dive);
            border-radius: 6px;
            padding: 10px 12px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 11px;
            color: var(--anenome);
            margin-bottom: 10px;
            overflow-x: auto;
        }

        .parameters {
            margin-top: 10px;
        }

        .param-title {
            font-size: 10px;
            font-weight: 600;
            color: var(--deep-dive);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .param-item {
            font-size: 12px;
            color: var(--bottlenose);
            margin-bottom: 4px;
            padding-left: 10px;
            line-height: 1.4;
        }
        
        .param-name {
            font-weight: 600;
            color: var(--deep-dive);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
        }

        .example {
            background: rgba(10, 226, 193, 0.08);
            border-left: 3px solid var(--anenome);
            padding: 12px;
            margin-top: 12px;
            border-radius: 4px;
        }
        
        .example-title {
            font-size: 10px;
            font-weight: 600;
            color: var(--deep-dive);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .example-code {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 11px;
            color: var(--deep-dive);
            background: var(--barnacle);
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
            margin: 2px 0;
        }

        .example-result {
            font-size: 10px;
            color: var(--bottlenose);
            margin-left: 8px;
            font-style: italic;
        }


        /* Loading Overlay - Modern & Animated */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(9, 35, 92, 0.97) 0%, rgba(0, 79, 182, 0.97) 100%);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            animation: fadeIn 0.3s ease-in-out;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            text-align: center;
            color: white;
            max-width: 400px;
            padding: 40px;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(168, 177, 206, 0.3);
            border-top: 4px solid var(--anenome);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 25px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 12px;
            color: white;
        }

        .loading-message {
            font-size: 14px;
            color: var(--chrome);
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .loading-progress {
            background: rgba(168, 177, 206, 0.2);
            border-radius: 20px;
            height: 6px;
            overflow: hidden;
            margin-top: 20px;
        }

        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--anenome), var(--tidal-wave));
            border-radius: 20px;
            width: 0%;
            transition: width 0.5s ease;
            box-shadow: 0 0 20px rgba(10, 226, 193, 0.5);
        }

        .loading-stats {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 15px;
            font-family: 'Monaco', 'Courier New', monospace;
        }
        
        .cancel-btn {
            margin-top: 20px;
            padding: 10px 24px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .cancel-btn:hover {
            background: rgba(220, 38, 38, 1);
            transform: scale(1.02);
        }
        
        .cancel-btn:disabled {
            background: rgba(107, 114, 128, 0.5);
            cursor: not-allowed;
        }
        
        /* Floating status widget for special formulas */
        .floating-status {
            position: fixed;
            bottom: 20px;
            left: 10px;
            right: 10px;
            background: linear-gradient(135deg, #1e3a5f 0%, #0d2137 100%);
            border-radius: 12px;
            padding: 14px 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .floating-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .floating-status-title {
            color: #93c5fd;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .floating-status-dismiss {
            background: none;
            border: none;
            color: rgba(255,255,255,0.5);
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            line-height: 1;
        }
        
        .floating-status-dismiss:hover {
            color: white;
        }
        
        .floating-status-message {
            color: white;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 8px;
        }
        
        .floating-status-detail {
            color: rgba(255,255,255,0.7);
            font-size: 11px;
        }
        
        .floating-status-progress {
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .floating-status-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .info-box {
            background: linear-gradient(135deg, rgba(10, 226, 193, 0.1) 0%, rgba(0, 121, 255, 0.05) 100%);
            border: 1px solid var(--anenome);
            border-radius: 8px;
            padding: 12px;
            margin: 12px 0;
        }

        .info-box p {
            font-size: 12px;
            color: var(--deep-dive);
            line-height: 1.5;
        }

        .info-box strong {
            color: var(--blue-light);
        }

        .info-box code {
            background: var(--deep-dive);
            color: var(--anenome);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }

        /* Toast Notification System */
        .toast-container {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 320px;
            pointer-events: none;
        }

        .toast {
            background: var(--deep-dive);
            border-radius: 10px;
            padding: 14px 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3), 0 2px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: flex-start;
            gap: 12px;
            animation: toastSlideIn 0.3s ease-out;
            pointer-events: auto;
            border-left: 4px solid var(--anenome);
        }

        .toast.info { border-left-color: var(--tidal-wave); }
        .toast.success { border-left-color: #10b981; }
        .toast.warning { border-left-color: #f59e0b; }
        .toast.error { border-left-color: #ef4444; }
        .toast.calculating { border-left-color: #8b5cf6; }

        .toast-icon {
            font-size: 18px;
            flex-shrink: 0;
            margin-top: 2px;
        }

        .toast-content {
            flex: 1;
            min-width: 0;
        }

        .toast-title {
            font-weight: 600;
            font-size: 13px;
            color: white;
            margin-bottom: 4px;
        }

        .toast-message {
            font-size: 11px;
            color: var(--chrome);
            line-height: 1.4;
            word-break: break-word;
        }

        .toast-message code {
            background: rgba(10, 226, 193, 0.2);
            color: var(--anenome);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            display: inline-block;
            margin-top: 4px;
            cursor: pointer;
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--chrome);
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .toast-close:hover {
            opacity: 1;
        }

        @keyframes toastSlideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes toastSlideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .toast.removing {
            animation: toastSlideOut 0.3s ease-in forwards;
        }

        .toast-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-top: 2px solid #8b5cf6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body>
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div class="loading-title" id="loadingTitle">Processing...</div>
            <div class="loading-message" id="loadingMessage">Please wait while we fetch data from NetSuite</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="loadingProgressBar"></div>
            </div>
            <div class="loading-stats" id="loadingStats"></div>
            <button id="cancelRefreshBtn" class="cancel-btn" onclick="cancelRefresh()" style="display: none;">
                 Cancel Refresh
            </button>
        </div>
    </div>

    <!-- Floating Status Widget for Special Formulas -->
    <div class="floating-status" id="floatingStatus">
        <div class="floating-status-header">
            <span class="floating-status-title"> Background Processing</span>
            <button class="floating-status-dismiss" onclick="hideFloatingStatus()"></button>
        </div>
        <div class="floating-status-message" id="floatingStatusMessage">Processing special formulas...</div>
        <div class="floating-status-detail" id="floatingStatusDetail">You can continue working while these complete.</div>
        <div class="floating-status-progress">
            <div class="floating-status-progress-bar" id="floatingStatusProgressBar" style="width: 0%"></div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal" onclick="if(event.target === this) closeSettings()">
        <div class="settings-panel">
            <div class="settings-header">
                <h2> Settings</h2>
                <button class="settings-close" onclick="closeSettings()"></button>
            </div>
            <div class="settings-content">
                <!-- Server Status -->
                <div class="settings-section">
                    <h3> Backend Server</h3>
                    <div id="serverStatus" class="status-indicator checking">
                        <span class="status-dot checking"></span>
                        Checking...
                    </div>
                    <div style="display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;">
                        <button class="settings-btn-action" onclick="checkServerStatus()">
                            Check Status
                        </button>
                        <button class="settings-btn-action secondary" onclick="reloadLookups()">
                            Reload Lookups
                        </button>
                        <button class="settings-btn-action" onclick="restartServer()" style="background: #dc2626;">
                             Restart Server
                        </button>
                    </div>
                    <p style="font-size: 11px; color: var(--bottlenose); margin-top: 8px;">
                        Restart if you've updated backend code or see connection issues.
                    </p>
                </div>

                <!-- Tunnel Status -->
                <div class="settings-section">
                    <h3> Cloudflare Tunnel</h3>
                    <div id="tunnelStatus" class="status-indicator checking">
                        <span class="status-dot checking"></span>
                        Checking...
                    </div>
                    
                    <div style="margin-top: 12px; padding: 12px; background: linear-gradient(135deg, rgba(10, 226, 193, 0.1) 0%, rgba(0, 121, 255, 0.05) 100%); border-radius: 8px; border: 1px solid var(--anenome);">
                        <p style="font-size: 11px; color: var(--deep-dive); margin-bottom: 8px; font-weight: 600;">
                             Tunnel cannot be auto-restarted from add-in
                        </p>
                        <p style="font-size: 11px; color: var(--bottlenose); margin-bottom: 10px;">
                            To restart tunnel, run in Terminal:
                        </p>
                        <div style="background: var(--deep-dive); padding: 8px 10px; border-radius: 6px; font-family: monospace; font-size: 10px; color: var(--anenome); margin-bottom: 10px;">
                            pkill cloudflared; cloudflared tunnel --url http://localhost:5002
                        </div>
                        <button class="settings-btn-action" onclick="copyTunnelCommand()" style="font-size: 11px; padding: 6px 12px; width: 100%;">
                             Copy Command
                        </button>
                    </div>
                    
                    <details style="margin-top: 12px;">
                        <summary style="font-size: 12px; color: var(--tidal-wave); cursor: pointer; font-weight: 500;">
                             Update Worker with new tunnel URL
                        </summary>
                        <div style="margin-top: 10px; padding: 12px; background: var(--barnacle); border-radius: 8px;">
                            <p style="font-size: 11px; color: var(--deep-dive); margin-bottom: 8px;">
                                After restarting tunnel, copy the new URL (shown in terminal) and update Cloudflare Worker:
                            </p>
                            <ol style="font-size: 11px; color: var(--bottlenose); padding-left: 20px; line-height: 1.8;">
                                <li>Copy the new <code>https://xxx.trycloudflare.com</code> URL from terminal</li>
                                <li>Go to <a href="https://dash.cloudflare.com" target="_blank" style="color: var(--tidal-wave);">Cloudflare Dashboard</a></li>
                                <li>Workers & Pages  <strong>netsuite-proxy</strong></li>
                                <li>Edit code  Update <code>TUNNEL_URL</code></li>
                                <li>Save and Deploy</li>
                            </ol>
                            <input type="text" id="newTunnelUrl" class="settings-input" 
                                   placeholder="Paste new tunnel URL here" 
                                   style="font-size: 11px; margin-top: 8px;"/>
                            <button class="settings-btn-action" onclick="copyWorkerCode()" style="font-size: 11px; padding: 6px 12px; margin-top: 8px; width: 100%;">
                                 Copy Worker Code with New URL
                            </button>
                        </div>
                    </details>
                </div>

                <!-- Cache Info -->
                <div class="settings-section">
                    <h3> Cache Status</h3>
                    <div id="cacheInfo" style="font-size: 12px; color: #4b5563;">
                        <p>LocalStorage: <span id="localStorageStatus">Checking...</span></p>
                        <p style="margin-top: 4px;">Cached accounts: <span id="cachedAccountsCount">-</span></p>
                    </div>
                </div>

                <!-- Version Info -->
                <div class="settings-section">
                    <h3> Version Info</h3>
                    <div style="font-size: 12px; color: #4b5563;">
                        <p>Add-in Version: <strong id="settingsVersion">loading...</strong></p>
                        <p style="margin-top: 4px;">Proxy URL: <code style="font-size: 10px; background: #f3f4f6; padding: 2px 6px; border-radius: 4px;">netsuite-proxy.chris-corcoran.workers.dev</code></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <button class="settings-btn" onclick="openSettings()" title="Settings">
                <svg viewBox="0 0 24 24"><path fill="currentColor" d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/></svg>
            </button>
            <h1>Financial Reporting Engine</h1>
            <p>Real-time NetSuite data in your spreadsheets</p>
            <div class="version-badge" id="versionBadge">v...</div>
        </div>

        <div class="content">
            <div class="status-badge connected" id="connectionStatus" onclick="checkConnectionStatus()" title="Click to check connection">
                <span id="connectionText">Checking connection...</span>
            </div>

            <!-- QUICK START - Accordion Section -->
            <details class="collapsible-section help-section" id="quickStartSection" open>
                <summary class="collapsible-header" style="background: linear-gradient(135deg, var(--deep-dive) 0%, var(--blue-light) 100%);">
                    <h3 style="color: white;"><span class="icon"></span> Quick Start</h3>
                    <svg class="chevron" style="fill: white;" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content" style="background: linear-gradient(135deg, rgba(9, 35, 92, 0.05) 0%, rgba(0, 79, 182, 0.05) 100%);">
                    <p style="font-size: 12px; line-height: 1.6; color: var(--bottlenose); margin-bottom: 16px;">
                        The best way to learn how to use the <strong>Financial Reporting Engine (FRE)</strong> is to see it in action. 
                        Choose <strong>Sample Report</strong> below and we'll pull in 35 of your P&L accounts and build formulas for each month. 
                        We'll leave the last 10 rows empty so you can see how easy it is to drag and drop your formulasthat's the beauty of using Excel formulas for financial data!
                    </p>
                    <p style="font-size: 12px; line-height: 1.6; color: var(--bottlenose); margin-bottom: 16px;">
                        If you want to see all of your accounts, choose <strong>Full Income Statement</strong> and we'll examine your NetSuite account to create a beautifully formatted income statement with filters for year and subsidiary. 
                        Since every NetSuite account is different, <strong>we highly recommend you verify our work</strong> against your NetSuite reports at least once.
                    </p>
                    
                    <!-- Option 1: Sample Report -->
                    <div class="guide-choice" onclick="runGuideMe()" style="margin-bottom: 12px; background: rgba(255,255,255,0.8); border: 2px solid var(--deep-dive);">
                        <div class="guide-choice-icon"></div>
                        <div class="guide-choice-content">
                            <div class="guide-choice-title" style="color: var(--deep-dive);">Sample Report (Learn)</div>
                            <div class="guide-choice-desc" style="color: var(--bottlenose);">35 accounts with formulas you can study and extend</div>
                        </div>
            </div>
                    
                    <!-- Option 2: Full Income Statement -->
                    <div class="guide-choice" onclick="generateFullIncomeStatement()" style="background: rgba(255,255,255,0.8); border: 2px solid var(--deep-dive);">
                        <div class="guide-choice-icon"></div>
                        <div class="guide-choice-content">
                            <div class="guide-choice-title" style="color: var(--deep-dive);">Full Income Statement</div>
                            <div class="guide-choice-desc" style="color: var(--bottlenose);">Complete P&L with all accounts, sections, and totals</div>
                        </div>
                    </div>
                    
                    <div class="guide-me-progress" id="guideMeProgress" style="display: none; margin-top: 12px;"></div>
                </div>
            </details>

            <!-- GETTING STARTED HELP SECTION -->
            <details class="collapsible-section help-section" id="helpSection">
                <summary class="collapsible-header">
                    <h3><span class="icon"></span> Getting Started Guide</h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content">
                    <div class="help-tip">
                        <h4> Quick Start</h4>
                        <p>Type formulas directly in any Excel cell. Start with <code>=XAVI.BALANCE("4220", "Jan 2024", "Jan 2024")</code> to get account 4220's January balance!</p>
                    </div>
                    
                    <div class="help-tip" style="background: linear-gradient(135deg, rgba(26, 90, 62, 0.1) 0%, rgba(45, 138, 95, 0.1) 100%); border-color: #2d8a5f;">
                        <h4> Pro Tip: Load Data First</h4>
                        <p>For the fastest experience, use <strong>Data Management  Load Data</strong> before building your report:</p>
                        <ol style="margin: 8px 0 0 16px; font-size: 12px; line-height: 1.6;">
                            <li>Select cells containing your date headers (e.g., Jan 2025, Feb 2025)</li>
                            <li>Click <strong>Load Data for Selected Dates</strong></li>
                            <li>All GL data is pre-cached  formulas resolve instantly!</li>
                        </ol>
                        <p style="margin-top: 8px; font-size: 11px; color: var(--bottlenose);">Check "Include Balance Sheet Accounts" if you need Cash, AR, AP, etc.</p>
                    </div>
                    
                    <h4 style="color: var(--deep-dive); margin: 16px 0 10px; font-size: 14px;">Available Formulas</h4>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.BALANCE(account, startPeriod, endPeriod, [subsidiary], [dept], [location], [class])</code>
                        <span class="result">Returns: Account balance for the period</span>
                    </div>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.NAME(account)</code>
                        <span class="result">Returns: Account name (e.g., "Revenue - Products")</span>
                    </div>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.TYPE(account)</code>
                        <span class="result">Returns: Account type (e.g., "Income", "Expense")</span>
                    </div>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.PARENT(account)</code>
                        <span class="result">Returns: Parent account number</span>
                    </div>
                    
                    <h4 style="color: var(--deep-dive); margin: 20px 0 10px; font-size: 14px;"> Making Formulas Dynamic</h4>
                    <p style="color: var(--bottlenose); font-size: 12px; line-height: 1.5; margin-bottom: 12px;">
                        The real power comes from using <strong>cell references</strong> instead of hardcoded values. This lets you drag formulas and build dynamic reports!
                    </p>
                    
                    <div class="dynamic-demo">
                        <h5>Example: Dynamic Income Statement</h5>
                        <div class="excel-grid" style="grid-template-columns: 40px repeat(2, 1fr);">
                            <div class="excel-cell header"></div>
                            <div class="excel-cell header">A</div>
                            <div class="excel-cell header">B</div>
                            
                            <div class="excel-cell row-header">1</div>
                            <div class="excel-cell value">Account</div>
                            <div class="excel-cell value">Jan 2025</div>
                            
                            <div class="excel-cell row-header">2</div>
                            <div class="excel-cell">4220</div>
                            <div class="excel-cell formula">=XAVI.BALANCE($A2, B$1, B$1)</div>
                            
                            <div class="excel-cell row-header">3</div>
                            <div class="excel-cell">5000</div>
                            <div class="excel-cell formula drag-indicator">=XAVI.BALANCE($A3, B$1, B$1)</div>
                            
                            <div class="excel-cell row-header">4</div>
                            <div class="excel-cell">6100</div>
                            <div class="excel-cell formula drag-indicator">=XAVI.BALANCE($A4, B$1, B$1)</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 6px; margin-top: 10px; padding: 8px 10px; background: rgba(26, 90, 62, 0.1); border-radius: 6px;">
                            <span style="font-size: 16px;"></span>
                            <span style="font-size: 11px; color: var(--deep-dive);"><strong>Drag down</strong> to copy formula for all accounts</span>
                        </div>
                        <p style="font-size: 11px; color: var(--bottlenose); margin-top: 10px;">
                            <strong>The secret:</strong> <code>$A2</code> locks the column (A stays fixed), <code>B$1</code> locks the row (1 stays fixed). This lets you drag <strong>both directions</strong>  down for accounts, right for months!
                        </p>
                    </div>
                    
                    <div class="help-tip" style="margin-top: 16px;">
                        <h4> Pro Tip: Fast Data Entry</h4>
                        <p>1. Enter one formula in cell B2<br>
                        2. Drag <strong>down</strong> for all accounts (B2:B50)<br>
                        3. Then drag <strong>right</strong> for all months<br>
                        <strong>The add-in automatically batches requests!</strong></p>
                    </div>
                    
                    <h4 style="color: var(--deep-dive); margin: 20px 0 10px; font-size: 14px;"> Using Filters (Optional)</h4>
                    <p style="color: var(--bottlenose); font-size: 12px; line-height: 1.5; margin-bottom: 12px;">
                        Filter by subsidiary, department, location, or class. You can use names OR IDs:
                    </p>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.BALANCE("4220", "Jan 2024", "Jan 2024", "Celigo Inc.")</code>
                        <span class="result">Filter by subsidiary name</span>
                    </div>
                    
                    <div class="formula-example-box">
                        <code>=XAVI.BALANCE("4220", "Jan 2024", "Jan 2024", "", "Sales")</code>
                        <span class="result">Filter by department (leave subsidiary blank with "")</span>
                    </div>
                    
                    <div class="dynamic-demo" style="border-color: var(--anenome);">
                        <h5 style="color: var(--anenome);">Dynamic Filters with Cell References</h5>
                        <div class="excel-grid" style="grid-template-columns: 40px repeat(2, 1fr);">
                            <div class="excel-cell header"></div>
                            <div class="excel-cell header">A</div>
                            <div class="excel-cell header">B</div>
                            
                            <div class="excel-cell row-header">1</div>
                            <div class="excel-cell value">Subsidiary:</div>
                            <div class="excel-cell">Celigo Inc.</div>
                            
                            <div class="excel-cell row-header">2</div>
                            <div class="excel-cell value">Department:</div>
                            <div class="excel-cell">Sales</div>
                            
                            <div class="excel-cell row-header">4</div>
                            <div class="excel-cell">4220</div>
                            <div class="excel-cell formula" style="font-size: 8px;">=XAVI.BALANCE(A4, "Jan 2024", "Jan 2024", $B$1, $B$2)</div>
                        </div>
                        <p style="font-size: 11px; color: var(--bottlenose); margin-top: 8px;">
                            Reference filter values from cells using <code>$B$1</code> (fully locked) to change all formulas at once!
                        </p>
                    </div>
                </div>
            </details>

            <!-- DATA MANAGEMENT SECTION - Redesigned with integrated preload -->
            <details class="collapsible-section data-mgmt-section" id="dataMgmtSection" open>
                <summary class="collapsible-header">
                    <h3><span class="icon"></span> Data Management</h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content data-mgmt-content">
                    
                    <!-- PRELOAD SECTION - Primary action -->
                    <div class="data-section preload-section" id="preloadCard">
                        <div class="section-header">
                            <h4> Load Data for Fast Analysis</h4>
                            <span class="help-icon" data-tip="Select date headers (Jan 2025, Feb 2025, etc.) then click Load. All GL data for those periods will be cached for instant results.">?</span>
                        </div>
                        
                        <div class="preload-controls">
                            <button class="btn-load-data" id="preloadBtn" onclick="runPreloadSheet()">
                                <span id="preloadBtnText"> Load Data for Selected Dates</span>
                    </button>
                            
                            <label class="checkbox-row">
                                <input type="checkbox" id="includeBSCheckbox">
                                <span class="checkbox-label">Include Balance Sheet Accounts</span>
                                <span class="help-icon small" data-tip="BS accounts (Cash, AR, AP) need cumulative calculations. Adds 2-3 min but enables instant BS formulas.">?</span>
                            </label>
                        </div>
                        
                        <div class="preload-status" id="preloadProgress" style="display: none;"></div>
                    </div>
                    
                    <!-- REFRESH ACTIONS -->
                    <div class="data-section refresh-section">
                        <div class="section-header">
                            <h4> Refresh Options</h4>
                        </div>
                        
                        <div class="action-grid">
                            <button class="action-btn primary" onclick="refreshCurrentSheet()">
                                <span class="action-icon"></span>
                                <span class="action-text">Refresh Accounts</span>
                                <span class="help-icon small" data-tip="Refreshes all BALANCE formulas on this sheet. Auto-detects P&L and Balance Sheet accounts. P&L loads quickly (~30s/year), Balance Sheet takes 2-3 minutes.">?</span>
                            </button>
                            
                            <button class="action-btn secondary" onclick="refreshSelected()">
                                <span class="action-icon"></span>
                                <span class="action-text">Refresh Selected</span>
                                <span class="help-icon small" data-tip="Re-calculates only the cells you've selected. Faster than Refresh Accounts for quick updates.">?</span>
                            </button>
                            
                            <button class="action-btn warning" onclick="recalculateSpecialFormulas()">
                                <span class="action-icon"></span>
                                <span class="action-text">Recalculate Retained Earnings</span>
                                <span class="help-icon small" data-tip="Retained Earnings, Net Income, and Cumulative Translation Adjustment (CTA) require scanning your entire transaction history and applying currency consolidation. This can take up to 5 minutes. When to recalculate: After posting journal entries, after period close, or when values seem stale. You can continue working in your sheet while recalculating.">?</span>
                            </button>
                            
                            <button class="action-btn danger" onclick="clearCache()">
                                <span class="action-icon"></span>
                                <span class="action-text">Clear Cache</span>
                                <span class="help-icon small" data-tip="Erases all cached data. Forces formulas to re-query NetSuite on next calculation.">?</span>
                            </button>
                        </div>
                    
                    <div class="refresh-status" id="refreshStatus"></div>
                    </div>
                    
                </div>
            </details>

            <!-- NETSUITE FILTERS SECTION -->
            <details class="collapsible-section">
                <summary class="collapsible-header">
                    <h3><span class="icon"></span> NetSuite Filters</h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content">
                    <p style="color: var(--bottlenose); font-size: 12px; margin-bottom: 14px; line-height: 1.5;">
                        Select a filter and click "Insert" to add it to your cell. <strong>Tip:</strong> You can also type names directly in formulas!
                    </p>
                    
                    <div class="filter-group">
                        <label class="filter-label">Subsidiary</label>
                        <select id="subsidiarySelect" class="filter-select">
                            <option value="">Loading...</option>
                        </select>
                        <button class="btn-filter" onclick="insertLookupValue('subsidiary')">Insert</button>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">Department</label>
                        <select id="departmentSelect" class="filter-select">
                            <option value="">Loading...</option>
                        </select>
                        <button class="btn-filter" onclick="insertLookupValue('department')">Insert</button>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">Class</label>
                        <select id="classSelect" class="filter-select">
                            <option value="">Loading...</option>
                        </select>
                        <button class="btn-filter" onclick="insertLookupValue('class')">Insert</button>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">Location</label>
                        <select id="locationSelect" class="filter-select">
                            <option value="">Loading...</option>
                        </select>
                        <button class="btn-filter" onclick="insertLookupValue('location')">Insert</button>
                    </div>
                    
                    <div class="filter-group">
                        <label class="filter-label">Accounting Book <span style="font-size:10px;color:#888;">(Multi-Book)</span></label>
                        <select id="accountingBookSelect" class="filter-select">
                            <option value="1">Primary Book (Default)</option>
                        </select>
                        <button class="btn-filter" onclick="insertLookupValue('accountingBook')">Insert</button>
                    </div>
                    
                    <div class="refresh-status" id="lookupStatus"></div>
                </div>
            </details>

            <!-- ACCOUNT SEARCH SECTION -->
            <details class="collapsible-section">
                <summary class="collapsible-header">
                    <h3><span class="icon"></span> Bulk Add Accounts</h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content">
                    <p style="color: var(--bottlenose); font-size: 12px; margin-bottom: 12px; line-height: 1.5;">
                        Search by account number or type. Results insert at your cursor position.
                    </p>
                    
                    <input 
                        type="text" 
                        id="accountSearchInput" 
                        class="search-input"
                        placeholder="e.g., 4*, *income, expense"
                        onkeypress="if(event.key === 'Enter') searchAccounts()"
                    />
                    
                    <div class="search-hints">
                        <p style="color: var(--bottlenose); font-size: 11px; margin: 0; line-height: 1.6;">
                            <strong>By Number:</strong> <code>4*</code> <code>42*</code> <code>*</code><br>
                            <strong>By Type:</strong> <code>income</code> <code>expense</code> <code>bank</code> <code>asset</code>
                        </p>
                    </div>
                    
                    <button class="btn-primary" style="margin-top: 12px; background: linear-gradient(135deg, var(--anenome) 0%, #06d6a0 100%); color: var(--deep-dive);" onclick="searchAccounts()">
                        <span></span> Bulk Add Accounts
                    </button>
                    
                    <div class="refresh-status" id="searchStatus"></div>
                </div>
            </details>

            <!-- DRILL-DOWN SECTION -->
            <details class="collapsible-section">
                <summary class="collapsible-header">
                    <h3><span class="icon"></span> Transaction Drill-Down</h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content">
                    <p style="color: var(--bottlenose); font-size: 12px; margin-bottom: 12px; line-height: 1.5;">
                        Select any cell with an XAVI.BALANCE formula to see the underlying NetSuite transactions with links to original records.
                    </p>
                    <button class="btn-secondary" style="background: var(--tidal-wave);" onclick="drillDownTransactions()">
                        View Transactions
                    </button>
                    <div class="refresh-status" id="drillStatus"></div>
                </div>
            </details>

            <!-- FORMULA REFERENCE SECTION -->
            <details class="collapsible-section">
                <summary class="collapsible-header">
                    <h3><span class="icon"></span> Formula Reference</h3>
                    <svg class="chevron" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/></svg>
                </summary>
                <div class="collapsible-content">
    
            <!-- XAVI.NAME -->
            <div class="formula-card">
                <div class="formula-name">XAVI.NAME</div>
                <div class="formula-description">
                    Get the account name for any NetSuite account number or ID.
                </div>
                <div class="formula-syntax">
                    =XAVI.NAME(accountNumber)
                </div>
                <div class="parameters">
                    <div class="param-title">Parameters</div>
                    <div class="param-item">
                        <span class="param-name">accountNumber</span> - Account number or internal ID (numeric or text)
                    </div>
                </div>
                <div class="example">
                    <div class="example-title">Examples</div>
                    <div class="example-code">=XAVI.NAME(A4)</div>
                    <div class="example-code">=XAVI.NAME("4220")</div>
                    <div class="example-code">=XAVI.NAME("15000-1")</div>
                </div>
            </div>

            <!-- XAVI.TYPE -->
            <div class="formula-card">
                <div class="formula-name">XAVI.TYPE</div>
                <div class="formula-description">
                    Get the account type for any account (Income, Expense, Bank, AcctRec, Equity, etc.).
                </div>
                <div class="formula-syntax">
                    =XAVI.TYPE(accountNumber)
                </div>
                <div class="parameters">
                    <div class="param-title">Parameters</div>
                    <div class="param-item">
                        <span class="param-name">accountNumber</span> - Account number or internal ID (numeric or text)
                    </div>
                </div>
                <div class="example">
                    <div class="example-title">Examples</div>
                    <div class="example-code">=XAVI.TYPE("4220")</div>
                    <div class="example-result">Returns: "Income"</div>
                    <div class="example-code">=XAVI.TYPE("10010")</div>
                    <div class="example-result">Returns: "Bank"</div>
                </div>
            </div>

            <!-- XAVI.PARENT -->
            <div class="formula-card">
                <div class="formula-name">XAVI.PARENT</div>
                <div class="formula-description">
                    Get the parent account number for any sub-account (returns empty string if no parent).
                </div>
                <div class="formula-syntax">
                    =XAVI.PARENT(accountNumber)
                </div>
                <div class="parameters">
                    <div class="param-title">Parameters</div>
                    <div class="param-item">
                        <span class="param-name">accountNumber</span> - Account number or internal ID (numeric or text)
                    </div>
                </div>
                <div class="example">
                    <div class="example-title">Examples</div>
                    <div class="example-code">=XAVI.PARENT("4220")</div>
                    <div class="example-result">Returns: "4210"</div>
                    <div class="example-code">=XAVI.PARENT("4000")</div>
                    <div class="example-result">Returns: "" (top-level account)</div>
                </div>
            </div>

            <!-- XAVI.BALANCE -->
            <div class="formula-card">
                <div class="formula-name">XAVI.BALANCE</div>
                <div class="formula-description">
                    Get the GL account balance for a specific period or range, with optional filtering by subsidiary, department, location, and class.
                </div>
                <div class="formula-syntax">
                    =XAVI.BALANCE(account, fromPeriod, toPeriod, [subsidiary], [department], [location], [class])
                </div>
                <div class="parameters">
                    <div class="param-title">Required Parameters</div>
                    <div class="param-item">
                        <span class="param-name">account</span> - Account number or ID
                    </div>
                    <div class="param-item">
                        <span class="param-name">fromPeriod</span> - Starting period (e.g., "Jan 2025")
                    </div>
                    <div class="param-item">
                        <span class="param-name">toPeriod</span> - Ending period (e.g., "Dec 2025")
                    </div>
                    <div class="param-title" style="margin-top: 15px;">Optional Parameters</div>
                    <div class="param-item">
                        <span class="param-name">subsidiary</span> - Filter by subsidiary ID
                    </div>
                    <div class="param-item">
                        <span class="param-name">department</span> - Filter by department ID
                    </div>
                    <div class="param-item">
                        <span class="param-name">location</span> - Filter by location ID
                    </div>
                    <div class="param-item">
                        <span class="param-name">class</span> - Filter by class ID
                    </div>
                </div>
                <div class="example">
                    <div class="example-title">Examples</div>
                    <div class="example-code">=XAVI.BALANCE("4010", "Jan 2025", "Dec 2025")</div>
                    <div class="example-code">=XAVI.BALANCE(A4, B1, C1)</div>
                    <div class="example-code">=XAVI.BALANCE("4010", "Jan 2025", "Jan 2025", "", "13", "", "")</div>
        </div>
    </div>
    
            <!-- XAVI.BUDGET -->
            <div class="formula-card">
                <div class="formula-name">XAVI.BUDGET</div>
                <div class="formula-description">
                    Get the budget amount for an account and period, with optional filtering by subsidiary, department, location, and class.
                </div>
                <div class="formula-syntax">
                    =XAVI.BUDGET(account, fromPeriod, toPeriod, [subsidiary], [department], [location], [class])
                </div>
                <div class="parameters">
                    <div class="param-title">Required Parameters</div>
                    <div class="param-item">
                        <span class="param-name">account</span> - Account number or ID
                    </div>
                    <div class="param-item">
                        <span class="param-name">fromPeriod</span> - Starting period (e.g., "Jan 2025")
                    </div>
                    <div class="param-item">
                        <span class="param-name">toPeriod</span> - Ending period (e.g., "Dec 2025")
                    </div>
                    <div class="param-title" style="margin-top: 15px;">Optional Parameters</div>
                    <div class="param-item">
                        <span class="param-name">subsidiary</span> - Filter by subsidiary ID
                    </div>
                    <div class="param-item">
                        <span class="param-name">department</span> - Filter by department ID
                    </div>
                    <div class="param-item">
                        <span class="param-name">location</span> - Filter by location ID
                    </div>
                    <div class="param-item">
                        <span class="param-name">class</span> - Filter by class ID
                    </div>
                </div>
                <div class="example">
                    <div class="example-title">Examples</div>
                    <div class="example-code">=XAVI.BUDGET("5000", "Jan 2025", "Dec 2025")</div>
                    <div class="example-code">=XAVI.BUDGET(A4, B1, C1)</div>
                </div>
            </div>

            <!-- XAVI.RETAINEDEARNINGS -->
            <div class="formula-card">
                <div class="formula-name">XAVI.RETAINEDEARNINGS</div>
                <div class="formula-description">
                    Calculate Retained Earnings (cumulative P&L from company inception through prior fiscal year end). This value is computed dynamicallythere is no account to query.
                </div>
                <div class="formula-syntax">
                    =XAVI.RETAINEDEARNINGS(period, [subsidiary], [accountingBook], [class], [department], [location])
                </div>
                <div class="parameters">
                    <div class="param-title">Required Parameters</div>
                    <div class="param-item">
                        <span class="param-name">period</span> - Target period (e.g., "Dec 2024")
                    </div>
                    <div class="param-title" style="margin-top: 15px;">Optional Parameters</div>
                    <div class="param-item">
                        <span class="param-name">subsidiary</span> - Subsidiary ID or name
                    </div>
                    <div class="param-item">
                        <span class="param-name">accountingBook</span> - Accounting Book ID
                    </div>
                    <div class="param-item">
                        <span class="param-name">class, department, location</span> - Segment filters
                    </div>
                </div>
                <div class="example">
                    <div class="example-title">Examples</div>
                    <div class="example-code">=XAVI.RETAINEDEARNINGS("Dec 2024")</div>
                    <div class="example-code">=XAVI.RETAINEDEARNINGS(B1, "Celigo Inc.")</div>
                </div>
                <div class="help-tip" style="margin-top: 10px; font-size: 11px; color: var(--bottlenose);">
                     Takes up to 2 minutes due to historical data aggregation
                </div>
            </div>

            <!-- XAVI.NETINCOME -->
            <div class="formula-card">
                <div class="formula-name">XAVI.NETINCOME</div>
                <div class="formula-description">
                    Calculate Year-to-Date Net Income (sum of P&L from fiscal year start through target period). This value is computed dynamicallythere is no account to query.
                </div>
                <div class="formula-syntax">
                    =XAVI.NETINCOME(period, [subsidiary], [accountingBook], [class], [department], [location])
                </div>
                <div class="parameters">
                    <div class="param-title">Required Parameters</div>
                    <div class="param-item">
                        <span class="param-name">period</span> - Target period (e.g., "Jan 2025")
                    </div>
                    <div class="param-title" style="margin-top: 15px;">Optional Parameters</div>
                    <div class="param-item">
                        <span class="param-name">subsidiary</span> - Subsidiary ID or name
                    </div>
                    <div class="param-item">
                        <span class="param-name">accountingBook</span> - Accounting Book ID
                    </div>
                    <div class="param-item">
                        <span class="param-name">class, department, location</span> - Segment filters
                    </div>
                </div>
                <div class="example">
                    <div class="example-title">Examples</div>
                    <div class="example-code">=XAVI.NETINCOME("Jan 2025")</div>
                    <div class="example-code">=XAVI.NETINCOME(B1, "Celigo Inc.")</div>
                </div>
                <div class="help-tip" style="margin-top: 10px; font-size: 11px; color: var(--bottlenose);">
                     Takes 1020 seconds due to P&L aggregation
                </div>
            </div>

            <!-- XAVI.CTA -->
            <div class="formula-card">
                <div class="formula-name">XAVI.CTA</div>
                <div class="formula-description">
                    Calculate Cumulative Translation Adjustment (FX plug for multi-currency consolidated Balance Sheets). Uses the "plug method" for 100% accuracy.
                </div>
                <div class="formula-syntax">
                    =XAVI.CTA(period, [subsidiary], [accountingBook])
                </div>
                <div class="parameters">
                    <div class="param-title">Required Parameters</div>
                    <div class="param-item">
                        <span class="param-name">period</span> - Target period (e.g., "Dec 2024")
                    </div>
                    <div class="param-title" style="margin-top: 15px;">Optional Parameters</div>
                    <div class="param-item">
                        <span class="param-name">subsidiary</span> - Subsidiary ID or name
                    </div>
                    <div class="param-item">
                        <span class="param-name">accountingBook</span> - Accounting Book ID
                    </div>
                </div>
                <div class="example">
                    <div class="example-title">Examples</div>
                    <div class="example-code">=XAVI.CTA("Dec 2024")</div>
                    <div class="example-code">=XAVI.CTA(B1, "Celigo Inc.")</div>
                </div>
                <div class="help-tip" style="margin-top: 10px; font-size: 11px; color: var(--bottlenose);">
                     Takes 60+ seconds (runs 6 parallel queries for assets, liabilities, equity, RE, NI)
                </div>
            </div>
    
                    <div class="help-tip" style="margin-top: 16px;">
                        <h4> Pro Tip: Date Formatting</h4>
                        <p>Use TEXT() to format date cells:<br>
                        <code style="background: var(--deep-dive); color: var(--anenome); padding: 2px 6px; border-radius: 4px; font-size: 11px;">=XAVI.BALANCE("4010", TEXT(C3,"mmm yyyy"), TEXT(D3,"mmm yyyy"))</code></p>
                    </div>
                </div>
            </details>
        </div>

        <div class="footer">
            <p><a href="https://www.cloudextend.io" target="_blank">CloudExtend</a> Financial Reporting Engine for NetSuite</p>
        </div>
    </div>
    
    <!-- Centered Status Overlay -->
    <div id="statusBar" class="status-overlay" style="display: none;">
        <div class="status-card">
            <div class="status-content">
                <span class="status-icon" id="statusIcon"></span>
                <span class="status-text" id="statusText">Processing...</span>
            </div>
            <div class="status-progress-bar">
                <div class="status-progress" id="statusProgress" style="width: 0%;"></div>
            </div>
        </div>
    </div>
    
    <style>
        .status-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .status-card {
            background: linear-gradient(135deg, #1a365d 0%, #0f2744 100%);
            color: white;
            padding: 20px 28px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            border: 2px solid var(--anenome, #0AE2C1);
            min-width: 280px;
            max-width: 90%;
        }
        .status-content {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        .status-icon {
            font-size: 24px;
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .status-text {
            flex: 1;
            font-weight: 500;
            font-size: 14px;
        }
        .status-progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            overflow: hidden;
        }
        .status-progress {
            height: 100%;
            background: var(--anenome, #0AE2C1);
            transition: width 0.3s ease;
            border-radius: 3px;
        }
        .status-overlay.success .status-card {
            border-color: #10b981;
        }
        .status-overlay.success .status-progress {
            background: #10b981;
        }
        .status-overlay.error .status-card {
            border-color: #ef4444;
        }
        .status-overlay.error .status-progress {
            background: #ef4444;
        }
    </style>
    
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
    <script>
        const SERVER_URL = 'https://netsuite-proxy.chris-corcoran.workers.dev';
        
        // ========================================================================
        // VERSION - Single source of truth (update here when version changes)
        // ========================================================================
        const ADDIN_VERSION = '1.5.43.0';
        
        // ============================================
        // REFRESH CANCELLATION
        // ============================================
        let refreshCancelled = false;
        
        function cancelRefresh() {
            refreshCancelled = true;
            const cancelBtn = document.getElementById('cancelRefreshBtn');
            if (cancelBtn) {
                cancelBtn.disabled = true;
                cancelBtn.textContent = 'Cancelling...';
            }
            updateLoading('Cancelling...', null, 
                'Stopping after current operation completes. Any queries already sent to NetSuite will finish.');
            console.log(' Refresh cancelled by user');
        }
        
        function showCancelButton() {
            const cancelBtn = document.getElementById('cancelRefreshBtn');
            if (cancelBtn) {
                cancelBtn.style.display = 'block';
                cancelBtn.disabled = false;
                cancelBtn.textContent = ' Cancel Refresh';
            }
        }
        
        function hideCancelButton() {
            const cancelBtn = document.getElementById('cancelRefreshBtn');
            if (cancelBtn) {
                cancelBtn.style.display = 'none';
            }
        }
        
        // ============================================
        // FLOATING STATUS WIDGET (for special formulas)
        // ============================================
        function showFloatingStatus(message, detail, progress = 0) {
            const widget = document.getElementById('floatingStatus');
            const msgEl = document.getElementById('floatingStatusMessage');
            const detailEl = document.getElementById('floatingStatusDetail');
            const progressBar = document.getElementById('floatingStatusProgressBar');
            
            if (widget) {
                widget.style.display = 'block';
                if (msgEl) msgEl.textContent = message;
                if (detailEl) detailEl.innerHTML = detail;
                if (progressBar) progressBar.style.width = `${progress}%`;
            }
        }
        
        function updateFloatingStatus(message, detail, progress) {
            const msgEl = document.getElementById('floatingStatusMessage');
            const detailEl = document.getElementById('floatingStatusDetail');
            const progressBar = document.getElementById('floatingStatusProgressBar');
            
            if (msgEl && message) msgEl.textContent = message;
            if (detailEl && detail) detailEl.innerHTML = detail;
            if (progressBar && progress !== undefined) progressBar.style.width = `${progress}%`;
        }
        
        function hideFloatingStatus() {
            const widget = document.getElementById('floatingStatus');
            if (widget) {
                widget.style.display = 'none';
            }
        }
        
        // ============================================
        // Set version in all UI elements
        function initializeVersion() {
            const versionBadge = document.getElementById('versionBadge');
            const settingsVersion = document.getElementById('settingsVersion');
            if (versionBadge) versionBadge.textContent = 'v' + ADDIN_VERSION;
            if (settingsVersion) settingsVersion.textContent = ADDIN_VERSION;
        }

        // ========================================================================
        // CONNECTION STATUS - Check if backend/tunnel is reachable
        // ========================================================================
        let lastConnectionCheck = null;
        let connectionCheckInterval = null;
        
        async function checkConnectionStatus(silent = false) {
            const statusBadge = document.getElementById('connectionStatus');
            const statusText = document.getElementById('connectionText');
            
            if (!statusBadge || !statusText) return false;
            
            // Show checking state
            statusBadge.className = 'status-badge checking';
            statusText.textContent = 'Checking...';
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000);
                
                const response = await fetch(`${SERVER_URL}/health`, {
                    method: 'GET',
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    statusBadge.className = 'status-badge connected';
                    statusText.textContent = `Connected (${data.account || 'NetSuite'})`;
                    lastConnectionCheck = { status: 'connected', time: Date.now() };
                    if (!silent) {
                        showToast({ type: 'success', title: 'Connection OK', message: 'Backend and tunnel are working.', duration: 3000 });
                    }
                    return true;
                } else if (response.status === 502 || response.status === 524 || response.status === 522) {
                    // Tunnel/proxy error
                    statusBadge.className = 'status-badge disconnected';
                    statusText.textContent = 'Tunnel Down';
                    lastConnectionCheck = { status: 'disconnected', time: Date.now(), error: `HTTP ${response.status}` };
                    if (!silent) {
                        showToast({ type: 'error', title: 'Tunnel Disconnected', 
                            message: `Error ${response.status}: The Cloudflare tunnel may have expired. Check the terminal for a new tunnel URL and update the Worker.`, duration: 10000 });
                    }
                    return false;
                } else {
                    statusBadge.className = 'status-badge disconnected';
                    statusText.textContent = `Error (${response.status})`;
                    lastConnectionCheck = { status: 'error', time: Date.now(), error: `HTTP ${response.status}` };
                    return false;
                }
            } catch (error) {
                statusBadge.className = 'status-badge disconnected';
                if (error.name === 'AbortError') {
                    statusText.textContent = 'Timeout';
                    lastConnectionCheck = { status: 'timeout', time: Date.now() };
                    if (!silent) {
                        showToast({ type: 'error', title: 'Connection Timeout', 
                            message: 'Could not reach the backend. The tunnel may have expired.', duration: 8000 });
                    }
                } else {
                    statusText.textContent = 'Disconnected';
                    lastConnectionCheck = { status: 'disconnected', time: Date.now(), error: error.message };
                    if (!silent) {
                        showToast({ type: 'error', title: 'Connection Failed', 
                            message: `Could not connect: ${error.message}`, duration: 8000 });
                    }
                }
                return false;
            }
        }
        
        // Start periodic connection checks (every 60 seconds)
        function startConnectionMonitor() {
            // Initial check (silent)
            checkConnectionStatus(true);
            
            // Periodic checks every 60 seconds
            connectionCheckInterval = setInterval(() => {
                checkConnectionStatus(true);
            }, 60000);
        }
        
        // Stop connection monitor when page unloads
        window.addEventListener('beforeunload', () => {
            if (connectionCheckInterval) {
                clearInterval(connectionCheckInterval);
            }
        });

        // ========================================================================
        // STATUS BAR - Persistent Progress Messages
        // ========================================================================
        function showStatus(message, icon = '', progress = 0, type = '') {
            const bar = document.getElementById('statusBar');
            const textEl = document.getElementById('statusText');
            const iconEl = document.getElementById('statusIcon');
            const progressEl = document.getElementById('statusProgress');
            
            bar.className = 'status-overlay' + (type ? ' ' + type : '');
            bar.style.display = 'flex';
            textEl.textContent = message;
            iconEl.textContent = icon;
            progressEl.style.width = progress + '%';
        }
        
        function hideStatus(delay = 0) {
            setTimeout(() => {
                document.getElementById('statusBar').style.display = 'none';
            }, delay);
        }
        
        function showStatusSuccess(message) {
            showStatus(message, '', 100, 'success');
            hideStatus(3000);
        }
        
        function showStatusError(message) {
            showStatus(message, '', 100, 'error');
            hideStatus(5000);
        }
        
        // Poll for status updates from custom functions (via localStorage)
        let lastStatusTimestamp = 0;
        setInterval(() => {
            try {
                const statusJson = localStorage.getItem('netsuite_status');
                if (statusJson) {
                    const status = JSON.parse(statusJson);
                    // Only show if timestamp is newer than last shown
                    if (status.timestamp > lastStatusTimestamp) {
                        lastStatusTimestamp = status.timestamp;
                        const icon = status.type === 'success' ? '' : 
                                     status.type === 'error' ? '' : '';
                        showStatus(status.message, icon, status.progress, status.type);
                        
                        // Auto-hide success/error after delay
                        if (status.type === 'success' || status.type === 'error') {
                            hideStatus(3000);
                        }
                    }
                }
            } catch (e) {
                // Ignore parsing errors
            }
        }, 500);  // Check every 500ms

        // Poll for toast notifications from custom functions (via localStorage)
        let lastToastTimestamp = 0;
        let lastToastUpdateTimestamp = 0;
        let lastToastRemoveTimestamp = 0;
        const broadcastToastMap = new Map(); // Maps broadcast toast IDs to local toast IDs
        
        setInterval(() => {
            try {
                // Check for new toasts
                const toastJson = localStorage.getItem('netsuite_toast');
                if (toastJson) {
                    const toast = JSON.parse(toastJson);
                    if (toast.timestamp > lastToastTimestamp) {
                        lastToastTimestamp = toast.timestamp;
                        // Create local toast and map the ID
                        const localId = showToast({
                            title: toast.title,
                            message: toast.message,
                            type: toast.type,
                            duration: toast.duration
                        });
                        broadcastToastMap.set(toast.id, localId);
                        localStorage.removeItem('netsuite_toast');
                    }
                }
                
                // Check for toast updates
                const updateJson = localStorage.getItem('netsuite_toast_update');
                if (updateJson) {
                    const update = JSON.parse(updateJson);
                    if (update.timestamp > lastToastUpdateTimestamp) {
                        lastToastUpdateTimestamp = update.timestamp;
                        const localId = broadcastToastMap.get(update.id);
                        if (localId) {
                            updateToast(localId, {
                                title: update.title,
                                message: update.message,
                                type: update.type
                            });
                        }
                        localStorage.removeItem('netsuite_toast_update');
                    }
                }
                
                // Check for toast removals
                const removeJson = localStorage.getItem('netsuite_toast_remove');
                if (removeJson) {
                    const remove = JSON.parse(removeJson);
                    if (remove.timestamp > lastToastRemoveTimestamp) {
                        lastToastRemoveTimestamp = remove.timestamp;
                        const localId = broadcastToastMap.get(remove.id);
                        if (localId) {
                            removeToast(localId);
                            broadcastToastMap.delete(remove.id);
                        }
                        localStorage.removeItem('netsuite_toast_remove');
                    }
                }
            } catch (e) {
                // Ignore parsing errors
            }
        }, 300);  // Check every 300ms for responsive toasts

        // ========================================================================
        // LOADING OVERLAY - Modern Progress Indicator
        // ========================================================================
        function showLoading(title, message, progress = 0) {
            const overlay = document.getElementById('loadingOverlay');
            const titleEl = document.getElementById('loadingTitle');
            const messageEl = document.getElementById('loadingMessage');
            const progressBar = document.getElementById('loadingProgressBar');
            const statsEl = document.getElementById('loadingStats');
            
            titleEl.textContent = title || 'Processing...';
            messageEl.textContent = message || 'Please wait';
            progressBar.style.width = progress + '%';
            statsEl.textContent = '';
            
            overlay.classList.add('active');
        }

        function updateLoading(message, progress, stats) {
            const messageEl = document.getElementById('loadingMessage');
            const progressBar = document.getElementById('loadingProgressBar');
            const statsEl = document.getElementById('loadingStats');
            
            if (message) messageEl.textContent = message;
            if (progress !== undefined) progressBar.style.width = progress + '%';
            if (stats) statsEl.textContent = stats;
        }

        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.remove('active');
        }

        // ========================================================================
        // TOAST NOTIFICATION SYSTEM
        // ========================================================================
        let toastCounter = 0;
        
        /**
         * Show a toast notification
         * @param {object} options - Toast options
         * @param {string} options.title - Toast title
         * @param {string} options.message - Toast message (can include HTML)
         * @param {string} options.type - Toast type: 'info', 'success', 'warning', 'error', 'calculating'
         * @param {number} options.duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
         * @param {string} options.icon - Custom icon (emoji)
         * @returns {string} Toast ID for manual removal
         */
        function showToast({ title, message, type = 'info', duration = 5000, icon }) {
            const container = document.getElementById('toastContainer');
            const toastId = `toast-${++toastCounter}`;
            
            // Default icons by type
            const defaultIcons = {
                info: '',
                success: '',
                warning: '',
                error: '',
                calculating: '' // Will use spinner
            };
            
            const displayIcon = icon || defaultIcons[type] || '';
            const iconHtml = type === 'calculating' 
                ? '<div class="toast-spinner"></div>' 
                : `<span class="toast-icon">${displayIcon}</span>`;
            
            const toast = document.createElement('div');
            toast.id = toastId;
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                ${iconHtml}
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="removeToast('${toastId}')">&times;</button>
            `;
            
            container.appendChild(toast);
            
            // Auto-dismiss after duration (if set)
            if (duration > 0) {
                setTimeout(() => removeToast(toastId), duration);
            }
            
            return toastId;
        }
        
        function removeToast(toastId) {
            const toast = document.getElementById(toastId);
            if (toast) {
                toast.classList.add('removing');
                setTimeout(() => toast.remove(), 300);
            }
        }
        
        // Clear ALL toasts from the container
        function hideToast() {
            const container = document.getElementById('toastContainer');
            if (container) {
                const toasts = container.querySelectorAll('.toast');
                toasts.forEach(toast => {
                    toast.classList.add('removing');
                    setTimeout(() => toast.remove(), 300);
                });
            }
        }
        
        function updateToast(toastId, { title, message, type }) {
            const toast = document.getElementById(toastId);
            if (toast) {
                if (title) toast.querySelector('.toast-title').textContent = title;
                if (message) toast.querySelector('.toast-message').innerHTML = message;
                if (type) {
                    toast.className = `toast ${type}`;
                    // Update icon for non-calculating types
                    if (type !== 'calculating') {
                        const iconSpan = toast.querySelector('.toast-icon');
                        const spinner = toast.querySelector('.toast-spinner');
                        if (spinner) {
                            spinner.outerHTML = `<span class="toast-icon">${type === 'success' ? '' : type === 'error' ? '' : ''}</span>`;
                        }
                    }
                }
            }
        }
        
        // Make toast functions globally accessible for functions.js
        window.showToast = showToast;
        window.removeToast = removeToast;
        window.updateToast = updateToast;
        window.hideToast = hideToast;

        // ========================================================================
        // SETTINGS MODAL
        // ========================================================================
        function openSettings() {
            document.getElementById('settingsModal').classList.add('active');
            checkServerStatus();
            checkTunnelStatus();
            checkCacheStatus();
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }

        // ================================================================
        // GUIDE ME WIZARD - Build starter financial report
        // ================================================================
        
        function dismissGuideMe() {
            document.getElementById('guideMeCard').classList.add('guide-me-hidden');
            localStorage.setItem('guideMeDismissed', 'true');
        }

        function showGuideMe() {
            // Only show if not previously dismissed
            if (localStorage.getItem('guideMeDismissed') !== 'true') {
                document.getElementById('guideMeCard').classList.remove('guide-me-hidden');
            }
        }

        async function runGuideMe() {
            const btn = document.getElementById('guideMeBtn');
            const btnText = document.getElementById('guideMeBtnText');
            const progress = document.getElementById('guideMeProgress');
            const currentYear = new Date().getFullYear();
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // CRITICAL: Clear all caches to prevent stale account type data
            // This ensures XAVI.TYPE formulas fetch fresh data from NetSuite
            try {
                if (typeof window.clearAllCaches === 'function') {
                    window.clearAllCaches();
                    console.log('Guide Me: Cleared all frontend caches');
                }
                // Also clear localStorage cache
                localStorage.removeItem('netsuite_balance_cache');
                localStorage.removeItem('netsuite_balance_cache_timestamp');
                console.log('Guide Me: Cleared localStorage cache');
            } catch (e) {
                console.warn('Guide Me: Cache clear warning:', e.message);
            }
            
            // Excel tips to show during loading - finance-focused formulas and shortcuts
            const excelTips = [
                // Financial formulas
                '=SUMIF(range, criteria, sum_range)  Sum by condition',
                '=SUMIFS(sum_range, range1, criteria1, range2, criteria2)',
                '=VLOOKUP(value, table, col, FALSE)  Exact match lookup',
                '=INDEX(array, MATCH(value, range, 0))  Flexible lookup',
                '=IFERROR(formula, 0)  Handle #DIV/0! errors',
                '=SUMPRODUCT((A:A="Revenue")*(B:B))  Sum with multiple criteria',
                '=EOMONTH(date, 0)  Last day of month',
                '=EOMONTH(date, -1)+1  First day of month',
                '=TEXT(date, "mmmm yyyy")  Format dates',
                '=ROUND(value, -3)  Round to nearest thousand',
                '=ABS(value)  Absolute value for variances',
                '=IF(actual>budget, "Over", "Under")  Budget variance',
                '=YEAR(date) & "-" & TEXT(MONTH(date),"00")',
                '=(current-prior)/ABS(prior)  % change formula',
                '=AVERAGEIF(range, ">0")  Average positive values',
                '=COUNTIF(range, "<0")  Count negative variances',
                '=MAX(range)-MIN(range)  Range/spread analysis',
                '=RANK(value, range, 0)  Rank accounts by size',
                // Keyboard shortcuts
                'Ctrl+D  Fill down from cell above',
                'Ctrl+R  Fill right from cell left',
                'Ctrl+Shift+L  Toggle filters',
                'Ctrl+`  Show/hide formulas',
                'F4  Toggle absolute refs ($A$1)',
                'Alt+=  Auto-sum selected range',
                'Ctrl+;  Insert today\'s date',
                'Ctrl+Shift+#  Date format',
                'Ctrl+Shift+$  Currency format',
                'Ctrl+Shift+%  Percentage format',
                'F2  Edit cell directly',
                'Ctrl+[  Jump to precedent cell',
                // Pro tips
                'Name ranges for clearer formulas',
                'Use Tables (Ctrl+T) for dynamic ranges',
                'Conditional formatting for variances',
                'Data Validation for dropdown lists',
                'Pivot Tables for quick analysis'
            ];
            let tipIndex = 0;
            
            // Create and show loading overlay with progress bar
            const overlay = document.createElement('div');
            overlay.className = 'guide-me-overlay';
            overlay.id = 'guideMeOverlay';
            overlay.innerHTML = `
                <div class="loading-spinner"></div>
                <h2>Building Your Sample Report</h2>
                <div class="loading-subtitle">
                     First run takes up to 2 minutes to load and cache data
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar-bg">
                        <div class="progress-bar-fill" id="guideMeProgressBar"></div>
                    </div>
                    <div class="progress-text" id="guideMeProgressText">0% complete</div>
                </div>
                
                <div class="loading-step" id="guideMeStep">Connecting to NetSuite...</div>
                <div class="loading-step-desc" id="guideMeStepDesc">Establishing secure connection</div>
                
                <div class="tips-section">
                    <div class="tips-label">Excel Pro Tips</div>
                    <div class="loading-tip" id="guideMeTip">${excelTips[0]}</div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            // Rotate tips every 2.5 seconds
            const tipInterval = setInterval(() => {
                tipIndex = (tipIndex + 1) % excelTips.length;
                const tipEl = document.getElementById('guideMeTip');
                if (tipEl) {
                    tipEl.style.opacity = '0';
                    setTimeout(() => {
                        tipEl.textContent = excelTips[tipIndex];
                        tipEl.style.opacity = '1';
                    }, 200);
                }
            }, 2500);
            
            const updateProgress = (percent, step, desc) => {
                const bar = document.getElementById('guideMeProgressBar');
                const text = document.getElementById('guideMeProgressText');
                const stepEl = document.getElementById('guideMeStep');
                const descEl = document.getElementById('guideMeStepDesc');
                if (bar) bar.style.width = percent + '%';
                if (text) text.textContent = percent + '% complete';
                if (stepEl) stepEl.textContent = step;
                if (descEl) descEl.textContent = desc;
            };
            
            btn.disabled = true;
            
            try {
                // Step 1: Fetch ALL account data via full_year_refresh (preloads cache!)
                // This is the longest step - use artificial progress to keep user informed
                updateProgress(5, ' Step 1 of 4: Sampling Accounts', 
                    "We're sampling your accounts so we can return only accounts that have data for the year. This is a one-time step that takes some time...");
                
                // Start artificial progress increment during the long fetch
                let artificialProgress = 5;
                const progressInterval = setInterval(() => {
                    if (artificialProgress < 38) {
                        artificialProgress += 3;
                        updateProgress(artificialProgress, ' Step 1 of 4: Sampling Accounts', 
                            "Querying NetSuite for all account balances across 12 months...");
                    }
                }, 5000); // Increment every 5 seconds
                
                const refreshResponse = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        year: currentYear,
                        subsidiary: '',
                        department: '',
                        location: '',
                        class: ''
                    })
                });
                
                // Stop artificial progress
                clearInterval(progressInterval);
                
                updateProgress(40, ' Step 1 of 4: Sampling Accounts', 'Receiving data from NetSuite...');
                
                if (!refreshResponse.ok) {
                    throw new Error(`Failed to load data: ${refreshResponse.status}`);
                }
                
                const refreshData = await refreshResponse.json();
                const allBalances = refreshData.balances || {};
                const accountTypes = refreshData.account_types || {}; // { acctNum: "Income" | "Expense" | etc. }
                const accountNames = refreshData.account_names || {}; // { acctNum: "Account Name" }
                
                console.log(`Guide Me: Loaded ${Object.keys(allBalances).length} accounts from full_year_refresh`);
                console.log(`Guide Me: Account types received for ${Object.keys(accountTypes).length} accounts`);
                console.log(`Guide Me: Account names received for ${Object.keys(accountNames).length} accounts`);
                
                // CRITICAL: Populate the frontend cache so formulas can use the data!
                // This prevents #BUSY from appearing and makes formulas resolve instantly
                updateProgress(42, ' Preparing Data', 'Getting everything ready for fast analysis...');
                
                // IMPORTANT: Fill in $0 for ALL 12 months for each account
                // This prevents #BUSY for months with no transactions (they should show $0 instantly)
                const allMonthNames = monthNames.map(m => `${m} ${currentYear}`);
                let filledCount = 0;
                for (const acctNum in allBalances) {
                    for (const monthName of allMonthNames) {
                        if (allBalances[acctNum][monthName] === undefined) {
                            allBalances[acctNum][monthName] = 0;
                            filledCount++;
                        }
                    }
                }
                console.log(`Guide Me: Filled ${filledCount} missing month/account combinations with $0`);
                
                try {
                    // Save to localStorage (shared with functions.js)
                    const STORAGE_KEY = 'netsuite_balance_cache';
                    const STORAGE_TIMESTAMP_KEY = 'netsuite_balance_cache_timestamp';
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(allBalances));
                    localStorage.setItem(STORAGE_TIMESTAMP_KEY, Date.now().toString());
                    console.log('Guide Me: Saved balances to localStorage (including $0 for missing months)');
                    
                    // Save account types to localStorage for persistence
                    localStorage.setItem('netsuite_type_cache', JSON.stringify(accountTypes));
                    console.log('Guide Me: Saved account types to localStorage');
                    
                    // Save account names to localStorage (prevents 35+ parallel requests!)
                    localStorage.setItem('netsuite_name_cache', JSON.stringify(accountNames));
                    console.log('Guide Me: Saved account names to localStorage');
                    
                    // Populate in-memory caches via Shared Runtime (if available)
                    if (typeof window.setFullYearCache === 'function') {
                        window.setFullYearCache(allBalances);
                        console.log('Guide Me: Populated balance cache via Shared Runtime');
                    }
                    
                    // Populate TYPE cache so XAVI.TYPE resolves correctly
                    if (typeof window.setAccountTypeCache === 'function') {
                        window.setAccountTypeCache(accountTypes);
                        console.log('Guide Me: Populated TYPE cache via Shared Runtime');
                    }
                    
                    // Populate NAME cache so XAVI.NAME resolves without 35+ API calls
                    if (typeof window.setAccountNameCache === 'function') {
                        window.setAccountNameCache(accountNames);
                        console.log('Guide Me: Populated NAME cache via Shared Runtime');
                    }
                } catch (cacheError) {
                    console.warn('Guide Me: Cache population warning:', cacheError.message);
                }
                
                // Step 2: Filter to accounts with actual data (at least one non-zero month)
                // PRIORITY: Income accounts first, then Expense accounts
                updateProgress(45, ' Step 2 of 4: Analyzing Data', 'Filtering accounts by type and data...');
                
                const incomeAccounts = [];
                const expenseAccounts = [];
                const otherAccounts = [];
                
                for (const acctNum in allBalances) {
                    const monthData = allBalances[acctNum];
                    const hasData = Object.values(monthData).some(val => val !== 0 && val !== null && val !== undefined);
                    
                    if (hasData) {
                        const monthValues = monthNames.map(m => monthData[`${m} ${currentYear}`] || 0);
                        const acctInfo = {
                            number: acctNum,
                            type: accountTypes[acctNum] || 'Unknown',
                            monthValues: monthValues,
                            total: monthValues.reduce((a, b) => a + b, 0)
                        };
                        
                        // Categorize by account type
                        const acctType = (accountTypes[acctNum] || '').toLowerCase();
                        if (acctType === 'income' || acctType === 'othincome') {
                            incomeAccounts.push(acctInfo);
                        } else if (acctType === 'expense' || acctType === 'othexpense' || acctType === 'cogs' || acctType === 'cost of goods sold') {
                            expenseAccounts.push(acctInfo);
                        } else {
                            otherAccounts.push(acctInfo);  // BS accounts, etc.
                        }
                    }
                }
                
                console.log(`Guide Me: Found ${incomeAccounts.length} Income, ${expenseAccounts.length} Expense, ${otherAccounts.length} Other accounts`);
                updateProgress(50, ' Step 2 of 4: Analyzing Data', `Found ${incomeAccounts.length} income accounts`);
                
                // Build final list: Income first (up to 35), then Expense to fill remaining
                let allAccounts = [];
                
                // Add Income accounts first (up to 35)
                allAccounts = allAccounts.concat(incomeAccounts.slice(0, 35));
                
                // If we need more, add Expense accounts
                const remaining = 35 - allAccounts.length;
                if (remaining > 0) {
                    allAccounts = allAccounts.concat(expenseAccounts.slice(0, remaining));
                    console.log(`Guide Me: Added ${Math.min(remaining, expenseAccounts.length)} Expense accounts to fill to 35`);
                }
                
                updateProgress(55, ' Step 2 of 4: Analyzing Data', `Selected ${allAccounts.length} accounts (Income + Expense)`);
                
                console.log(`Guide Me: Final selection: ${allAccounts.length} accounts`);
                
                if (allAccounts.length === 0) {
                    throw new Error('No Income or Expense accounts with transaction data found for ' + currentYear);
                }
                
                // Limit to 35 accounts (25 with formulas, 10 more with just account numbers)
                allAccounts = allAccounts.slice(0, 35);
                const formulaRows = 25; // Only first 25 get formulas
                
                // Step 3: Build the Excel template
                updateProgress(60, ' Step 3 of 4: Building Template', 'Creating headers and formatting...');
                
                // Get the default/parent subsidiary for the parameter cell
                let defaultSubsidiary = 'Celigo Inc. (Consolidated)'; // Will be fetched
                try {
                    const lookupsResponse = await fetch(`${SERVER_URL}/lookups/all`);
                    if (lookupsResponse.ok) {
                        const lookups = await lookupsResponse.json();
                        // Find the first consolidated/parent subsidiary
                        if (lookups.subsidiaries && lookups.subsidiaries.length > 0) {
                            // Look for one with "(Consolidated)" or the first one
                            const consolidated = lookups.subsidiaries.find(s => 
                                s.name.toLowerCase().includes('consolidated') || 
                                s.name.toLowerCase().includes('parent')
                            );
                            defaultSubsidiary = consolidated ? consolidated.name : lookups.subsidiaries[0].name;
                        }
                    }
                } catch (e) {
                    console.warn('Guide Me: Could not fetch subsidiary, using default');
                }
                
                await Excel.run(async (context) => {
                    console.log('Guide Me: Starting Excel.run');
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Try to rename sheet (may fail if name exists)
                    try {
                        sheet.name = "Income Statement";
                        await context.sync();
                    } catch (e) {
                        console.log('Guide Me: Sheet rename skipped');
                    }
                    
                    // Remove gridlines for cleaner look
                    try {
                    sheet.showGridlines = false;
                        await context.sync();
                    } catch (e) {
                        console.warn('Could not hide gridlines');
                    }
                    
                    // ========================================
                    // ROW 1-2: PARAMETER SECTION
                    // ========================================
                    console.log('Guide Me: Creating parameter section...');
                    
                    // Row 1: Title/spacing
                    const titleCell = sheet.getRange("A1");
                    titleCell.values = [[" Income Statement Parameters"]];
                    await context.sync();
                    
                    try {
                        titleCell.format.font.bold = true;
                        titleCell.format.font.size = 14;
                        titleCell.format.font.color = "#09235C";
                        await context.sync();
                    } catch (e) {}
                    
                    // Row 2: Parameter labels and values
                    // YEAR parameter
                    const yearLabel = sheet.getRange("E2");
                    yearLabel.values = [["YEAR"]];
                    
                    const yearValue = sheet.getRange("F2");
                    yearValue.values = [[currentYear]];
                    
                    // Subsidiary parameter  
                    const subLabel = sheet.getRange("H2");
                    subLabel.values = [["Subsidiary"]];
                    
                    const subValue = sheet.getRange("I2");
                    subValue.values = [[defaultSubsidiary]];
                    
                    await context.sync();
                    console.log('Guide Me: Parameter values written');
                    
                    // Style parameter labels (dark blue text, bold)
                    try {
                        const labelRange = sheet.getRange("E2");
                        labelRange.format.font.bold = true;
                        labelRange.format.font.color = "#09235C";
                        
                        const subLabelRange = sheet.getRange("H2");
                        subLabelRange.format.font.bold = true;
                        subLabelRange.format.font.color = "#09235C";
                        await context.sync();
                    } catch (e) {}
                    
                    // Style parameter INPUT cells (brand teal background, white text, border)
                    try {
                        // Year input cell - teal/anenome color
                        const yearInput = sheet.getRange("F2");
                        yearInput.format.fill.color = "#0AE2C1"; // Anenome teal
                        yearInput.format.font.bold = true;
                        yearInput.format.font.color = "#09235C";
                        yearInput.format.borders.getItem('EdgeTop').style = 'Continuous';
                        yearInput.format.borders.getItem('EdgeBottom').style = 'Continuous';
                        yearInput.format.borders.getItem('EdgeLeft').style = 'Continuous';
                        yearInput.format.borders.getItem('EdgeRight').style = 'Continuous';
                        yearInput.format.borders.getItem('EdgeTop').color = '#09235C';
                        yearInput.format.borders.getItem('EdgeBottom').color = '#09235C';
                        yearInput.format.borders.getItem('EdgeLeft').color = '#09235C';
                        yearInput.format.borders.getItem('EdgeRight').color = '#09235C';
                        
                        // Subsidiary input cell - teal/anenome color
                        const subInput = sheet.getRange("I2");
                        subInput.format.fill.color = "#0AE2C1"; // Anenome teal
                        subInput.format.font.bold = true;
                        subInput.format.font.color = "#09235C";
                        subInput.format.borders.getItem('EdgeTop').style = 'Continuous';
                        subInput.format.borders.getItem('EdgeBottom').style = 'Continuous';
                        subInput.format.borders.getItem('EdgeLeft').style = 'Continuous';
                        subInput.format.borders.getItem('EdgeRight').style = 'Continuous';
                        subInput.format.borders.getItem('EdgeTop').color = '#09235C';
                        subInput.format.borders.getItem('EdgeBottom').color = '#09235C';
                        subInput.format.borders.getItem('EdgeLeft').color = '#09235C';
                        subInput.format.borders.getItem('EdgeRight').color = '#09235C';
                        
                        await context.sync();
                        console.log('Guide Me: Parameter styling applied');
                    } catch (styleErr) {
                        console.warn('Guide Me: Parameter style warning:', styleErr.message);
                    }
                    
                    // ========================================
                    // ROW 3: Blank separator
                    // ========================================
                    
                    // ========================================
                    // ROW 4: COLUMN HEADERS
                    // ========================================
                    const headerRow = 4;
                    console.log('Guide Me: Writing column headers...');
                    
                    // Write text headers (A4:C4)
                    const cellA4 = sheet.getRange("A4");
                    cellA4.values = [["Type"]];
                    
                    const cellB4 = sheet.getRange("B4");
                    cellB4.values = [["Account #"]];
                    
                    const cellC4 = sheet.getRange("C4");
                    cellC4.values = [["Account Name"]];
                    
                    await context.sync();
                    console.log('Guide Me: Text header values written');
                    
                    // Format header row
                    try {
                        const headerRange = sheet.getRange("A4:C4");
                        headerRange.format.font.bold = true;
                        headerRange.format.font.color = "#FFFFFF";
                        headerRange.format.fill.color = "#09235C";
                        await context.sync();
                        console.log('Guide Me: Header formatting applied');
                    } catch (formatErr) {
                        console.warn('Guide Me: Header format warning:', formatErr.message);
                    }
                    
                    console.log('Guide Me: Writing date headers with dynamic year formula...');
                    
                    // Write date headers (D4:O4) using DATE formula that references the YEAR parameter
                    // Formula: =DATE($F$2, COLUMN()-COLUMN($C$4)+1, 1)
                    // D4 = month 1, E4 = month 2, etc.
                    for (let m = 0; m < 12; m++) {
                        const colLetter = String.fromCharCode(68 + m); // D=68
                        const cell = sheet.getRange(`${colLetter}4`);
                        // COLUMN(D4)=4, COLUMN($C$4)=3, so 4-3+1=2... we need 4-3=1 for Jan
                        // Actually: COLUMN()-COLUMN($C$4) gives D=4-3=1, E=5-3=2, etc. Perfect!
                        cell.formulas = [[`=DATE($F$2,COLUMN()-COLUMN($C$4),1)`]];
                    }
                    
                    await context.sync();
                    console.log('Guide Me: Date formulas written');
                    
                    // Format month headers
                    try {
                        const monthHeaderRange = sheet.getRange("D4:O4");
                        monthHeaderRange.numberFormat = [['mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm']];
                    monthHeaderRange.format.font.bold = true;
                    monthHeaderRange.format.font.color = "#FFFFFF";
                    monthHeaderRange.format.fill.color = "#09235C";
                        await context.sync();
                        console.log('Guide Me: Month header formatting applied');
                    } catch (monthFormatErr) {
                        console.warn('Guide Me: Month format warning:', monthFormatErr.message);
                    }
                    
                    // Write YTD Total header (P4)
                    const totalHeaderRange = sheet.getRange("P4");
                    totalHeaderRange.values = [['YTD Total']];
                    
                    await context.sync();
                    console.log('Guide Me: YTD header written');
                    
                    // Format YTD header
                    try {
                        const ytdRange = sheet.getRange("P4");
                        ytdRange.format.font.bold = true;
                        ytdRange.format.font.color = "#FFFFFF";
                        ytdRange.format.fill.color = "#09235C";
                        await context.sync();
                        console.log('Guide Me: YTD formatting applied');
                    } catch (ytdFormatErr) {
                        console.warn('Guide Me: YTD format warning:', ytdFormatErr.message);
                    }
                    
                    // ========================================
                    // ROW 5+: DATA ROWS
                    // ========================================
                    updateProgress(70, ' Step 4 of 4: Adding Formulas', `Writing ${allAccounts.length} accounts...`);
                    
                    const dataStartRow = 5; // Data starts at row 5
                    
                    // Write ALL 35 rows of account numbers, but only first 25 get formulas
                    for (let i = 0; i < allAccounts.length; i++) {
                        const acct = allAccounts[i];
                        const rowNum = dataStartRow + i; // Row 5, 6, 7, ...
                        
                        // Validate account number
                        if (!acct || !acct.number) {
                            console.warn(`Guide Me: Skipping row ${rowNum} - invalid account data`);
                            continue;
                        }
                        
                        try {
                        // Column B: Account NUMBER (always populated)
                        const numCell = sheet.getRange(`B${rowNum}`);
                            const acctNum = String(acct.number);
                            numCell.values = [[acctNum]];
                        
                        // Only add formulas for first 25 rows
                        if (i < formulaRows) {
                            // Column A: Account TYPE formula
                            const typeCell = sheet.getRange(`A${rowNum}`);
                            typeCell.formulas = [[`=XAVI.TYPE(B${rowNum})`]];
                            
                            // Column C: Account NAME formula
                            const nameCell = sheet.getRange(`C${rowNum}`);
                            nameCell.formulas = [[`=XAVI.NAME(B${rowNum})`]];
                            
                                // Columns D-O: BALANCE formulas with SUBSIDIARY parameter
                                // Formula: =XAVI.BALANCE($B5, TEXT(D$4,"mmm yyyy"), TEXT(D$4,"mmm yyyy"), $I$2)
                            for (let m = 0; m < 12; m++) {
                                const colLetter = String.fromCharCode(68 + m);
                                const cell = sheet.getRange(`${colLetter}${rowNum}`);
                                    cell.formulas = [[`=XAVI.BALANCE($B${rowNum},TEXT(${colLetter}$4,"mmm yyyy"),TEXT(${colLetter}$4,"mmm yyyy"),$I$2)`]];
                            }
                            
                            // Column P: YTD Total formula
                            const totalCell = sheet.getRange(`P${rowNum}`);
                            totalCell.formulas = [[`=SUM(D${rowNum}:O${rowNum})`]];
                        }
                        
                            // Alternating row colors
                        if (i % 2 === 0) {
                            const rowRange = sheet.getRange(`A${rowNum}:P${rowNum}`);
                            rowRange.format.fill.color = "#F5F7FA";
                            }
                        } catch (rowError) {
                            console.error(`Guide Me: Error writing row ${rowNum}:`, rowError.message);
                        }
                        
                        // Update progress every 5 rows
                        if (i % 5 === 0) {
                            updateProgress(70 + Math.floor((i / allAccounts.length) * 20), 
                                ' Step 4 of 4: Adding Formulas', 
                                `Processing row ${i + 1} of ${allAccounts.length}...`);
                        }
                    }
                    
                    await context.sync();
                    console.log(`Guide Me: Wrote ${allAccounts.length} accounts to sheet`);
                    
                    updateProgress(92, ' Finishing Up', 'Applying formatting...');
                    
                    // Format number columns as CURRENCY with no decimals
                    try {
                        const lastDataRow = dataStartRow + Math.min(allAccounts.length, 35) - 1;
                        const numRange = sheet.getRange(`D${dataStartRow}:P${lastDataRow}`);
                        const formatRows = lastDataRow - dataStartRow + 1;
                        const formatCols = 13; // columns D through P
                        const numberFormatArray = Array(formatRows).fill(null).map(() => 
                            Array(formatCols).fill('"$"#,##0')
                        );
                        numRange.numberFormat = numberFormatArray;
                        console.log(`Guide Me: Applied number format to D${dataStartRow}:P${lastDataRow}`);
                    } catch (formatError) {
                        console.warn('Guide Me: Number format warning:', formatError.message);
                    }
                    
                    await context.sync();
                    
                    // Add LEFT BORDER to YTD Total column (P)
                    try {
                        const lastDataRow = dataStartRow + Math.min(allAccounts.length, 35) - 1;
                        const totalColumn = sheet.getRange(`P4:P${lastDataRow}`);
                        const leftBorder = totalColumn.format.borders.getItem('EdgeLeft');
                        leftBorder.style = 'Continuous';
                        leftBorder.weight = 'Medium';
                        leftBorder.color = '#09235C';
                        console.log(`Guide Me: Applied border to P4:P${lastDataRow}`);
                    } catch (borderError) {
                        console.warn('Guide Me: Border formatting warning:', borderError.message);
                    }
                    
                    await context.sync();
                    
                    updateProgress(96, ' Finishing Up', 'Finalizing layout...');
                    
                    // Freeze rows 1-4 (parameters + header)
                    try {
                        sheet.freezePanes.freezeRows(4);
                        console.log('Guide Me: Froze header row');
                    } catch (freezeError) {
                        console.warn('Guide Me: Freeze panes warning:', freezeError.message);
                    }
                    
                    await context.sync();
                    
                    updateProgress(100, ' Complete!', 'Your report is ready!');
                });
                
                // Stop tip rotation
                clearInterval(tipInterval);
                
                // Remove overlay
                overlay.remove();
                
                // Calculate how many rows need formulas extended
                const extraRows = Math.min(10, allAccounts.length - formulaRows);
                const lastFormulaRow = 4 + formulaRows; // Row 29 (4 header rows + 25 formula rows)
                const lastDataRow = 4 + allAccounts.length; // Row 39 (4 header rows + 35 data rows)
                
                // Success message
                progress.style.display = 'block';
                progress.innerHTML = ` <strong>Here's your jump-start!</strong><br><br>
                    We loaded <strong>${allAccounts.length} accounts</strong> with data for ${currentYear}. 
                    The first <strong>${formulaRows} rows have formulas</strong>the remaining ${extraRows} rows have account numbers ready for you to extend.<br><br>
                    <div style="background: rgba(10, 226, 193, 0.15); padding: 10px 12px; border-radius: 8px; margin-bottom: 12px; border-left: 3px solid var(--anenome);">
                         <strong>Parameters:</strong> Change the <strong>YEAR</strong> (F2) or <strong>Subsidiary</strong> (I2) to refresh all formulas automatically!
                    </div>
                    <div style="background: rgba(10, 226, 193, 0.15); padding: 10px 12px; border-radius: 8px; margin-bottom: 12px; border-left: 3px solid var(--anenome);">
                         <strong>Note:</strong> You may see <code>#BUSY</code> in cells for a few seconds as data loads. This is normal!
                    </div>
                    <strong>To extend formulas to rows ${lastFormulaRow + 1}-${lastDataRow}:</strong><br>
                    1. Select cells <strong>A${lastFormulaRow}:C${lastFormulaRow}</strong> (Type, Account#, Name)<br>
                    2. Drag the fill handle down to row ${lastDataRow}<br>
                    3. Then select <strong>D${lastFormulaRow}:P${lastFormulaRow}</strong> (Jan through YTD Total)<br>
                    4. Drag down to row ${lastDataRow}<br><br>
                    <strong>Formula Reference:</strong><br>
                     <code>=XAVI.TYPE(B5)</code>  Account Type<br>
                     <code>=XAVI.NAME(B5)</code>  Account Name<br>
                     <code>=XAVI.BALANCE($B5,TEXT(D$4,"mmm yyyy"),TEXT(D$4,"mmm yyyy"),$I$2)</code>  Balance with Subsidiary`;
                progress.style.lineHeight = '1.6';
                btnText.textContent = ' Report Created!';
                btn.style.background = '#4CAF50';
                
            } catch (error) {
                console.error('Guide Me error:', error);
                clearInterval(tipInterval);
                if (document.getElementById('guideMeOverlay')) {
                    document.getElementById('guideMeOverlay').remove();
                }
                progress.style.display = 'block';
                progress.textContent = ` Error: ${error.message}`;
                btnText.textContent = 'Try Again';
                btn.disabled = false;
                btn.style.background = '';
            }
        }

        // ================================================================
        // GENERATE FULL INCOME STATEMENT
        // ================================================================
        
        async function generateFullIncomeStatement() {
            const progress = document.getElementById('guideMeProgress');
            const currentYear = new Date().getFullYear();
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Set flag to prevent auto-sync from triggering during generation
            isSyncInProgress = true;
            lastSyncedYear = currentYear;
            
            // Excel tips during loading
            const excelTips = [
                '=SUMIF(range, criteria, sum_range)  Sum by condition',
                '=INDEX(array, MATCH(value, range, 0))  Flexible lookup',
                'Ctrl+Shift+L  Toggle filters quickly',
                '=IFERROR(formula, 0)  Handle errors gracefully',
                'Alt+=  Auto-sum selected range',
                '=TEXT(date, "mmmm yyyy")  Format dates nicely',
                'F4  Toggle absolute refs ($A$1)',
                '=ROUND(value, -3)  Round to nearest thousand'
            ];
            let tipIndex = 0;
            
            // Create loading overlay
            const overlay = document.createElement('div');
            overlay.className = 'guide-me-overlay';
            overlay.id = 'incomeStatementOverlay';
            overlay.innerHTML = `
                <div class="loading-spinner"></div>
                <h2>Building Your Income Statement</h2>
                <div class="loading-subtitle">
                     This may take 2-3 minutes for large account sets
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar-bg">
                        <div class="progress-bar-fill" id="isProgressBar"></div>
                    </div>
                    <div class="progress-text" id="isProgressText">0% complete</div>
                </div>
                
                <div class="loading-step" id="isStep">Connecting to NetSuite...</div>
                <div class="loading-step-desc" id="isStepDesc">Establishing secure connection</div>
                
                <div class="tips-section">
                    <div class="tips-label">Excel Pro Tips</div>
                    <div class="loading-tip" id="isTip">${excelTips[0]}</div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            // Rotate tips
            const tipInterval = setInterval(() => {
                tipIndex = (tipIndex + 1) % excelTips.length;
                const tipEl = document.getElementById('isTip');
                if (tipEl) {
                    tipEl.style.opacity = '0';
                    setTimeout(() => {
                        tipEl.textContent = excelTips[tipIndex];
                        tipEl.style.opacity = '1';
                    }, 200);
                }
            }, 3000);
            
            const updateProgress = (percent, step, desc) => {
                const bar = document.getElementById('isProgressBar');
                const text = document.getElementById('isProgressText');
                const stepEl = document.getElementById('isStep');
                const descEl = document.getElementById('isStepDesc');
                if (bar) bar.style.width = percent + '%';
                if (text) text.textContent = percent + '% complete';
                if (stepEl) stepEl.textContent = step;
                if (descEl) descEl.textContent = desc;
            };
            
            try {
                // Step 1: Fetch ALL account data
                updateProgress(5, ' Step 1 of 5: Loading Accounts', 'Fetching all P&L accounts from NetSuite...');
                
                let artificialProgress = 5;
                const progressInterval = setInterval(() => {
                    if (artificialProgress < 30) {
                        artificialProgress += 2;
                        updateProgress(artificialProgress, ' Step 1 of 5: Loading Accounts', 
                            'Querying NetSuite for all account balances...');
                    }
                }, 4000);
                
                const refreshResponse = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        year: currentYear,
                        subsidiary: '',
                        department: '',
                        location: '',
                        class: ''
                    })
                });
                
                clearInterval(progressInterval);
                
                if (!refreshResponse.ok) {
                    throw new Error(`Failed to load data: ${refreshResponse.status}`);
                }
                
                const refreshData = await refreshResponse.json();
                const allBalances = refreshData.balances || {};
                const accountTypes = refreshData.account_types || {};
                const accountNames = refreshData.account_names || {};
                
                console.log(`Income Statement: Loaded ${Object.keys(allBalances).length} accounts`);
                
                // Step 2: Categorize accounts by type
                updateProgress(35, ' Step 2 of 5: Categorizing', 'Grouping accounts by type...');
                
                const categories = {
                    income: [],      // Revenue
                    othIncome: [],   // Other Income
                    cogs: [],        // Cost of Goods Sold
                    expense: [],     // Operating Expenses
                    othExpense: []   // Other Expenses
                };
                
                for (const acctNum in allBalances) {
                    const monthData = allBalances[acctNum];
                    const hasData = Object.values(monthData).some(val => val !== 0 && val !== null);
                    
                    if (hasData) {
                        const monthValues = monthNames.map(m => monthData[`${m} ${currentYear}`] || 0);
                        const acctInfo = {
                            number: acctNum,
                            name: accountNames[acctNum] || `Account ${acctNum}`,
                            type: accountTypes[acctNum] || 'Unknown',
                            monthValues: monthValues,
                            total: monthValues.reduce((a, b) => a + b, 0)
                        };
                        
                        const acctType = (accountTypes[acctNum] || '').toLowerCase();
                        if (acctType === 'income') {
                            categories.income.push(acctInfo);
                        } else if (acctType === 'othincome') {
                            categories.othIncome.push(acctInfo);
                        } else if (acctType === 'cogs' || acctType === 'cost of goods sold') {
                            categories.cogs.push(acctInfo);
                        } else if (acctType === 'expense') {
                            categories.expense.push(acctInfo);
                        } else if (acctType === 'othexpense') {
                            categories.othExpense.push(acctInfo);
                        }
                    }
                }
                
                // Sort each category by account number
                for (const cat in categories) {
                    categories[cat].sort((a, b) => a.number.localeCompare(b.number, undefined, {numeric: true}));
                }
                
                console.log(`Income Statement: Revenue=${categories.income.length}, OthIncome=${categories.othIncome.length}, COGS=${categories.cogs.length}, Expense=${categories.expense.length}, OthExpense=${categories.othExpense.length}`);
                
                // Get default subsidiary
                let defaultSubsidiary = 'Celigo Inc. (Consolidated)';
                try {
                    const lookupsResponse = await fetch(`${SERVER_URL}/lookups/all`);
                    if (lookupsResponse.ok) {
                        const lookups = await lookupsResponse.json();
                        if (lookups.subsidiaries && lookups.subsidiaries.length > 0) {
                            const consolidated = lookups.subsidiaries.find(s => 
                                s.name.toLowerCase().includes('consolidated') || 
                                s.name.toLowerCase().includes('parent')
                            );
                            defaultSubsidiary = consolidated ? consolidated.name : lookups.subsidiaries[0].name;
                        }
                    }
                } catch (e) {}
                
                // Step 3: Build Excel structure
                updateProgress(45, ' Step 3 of 5: Building Structure', 'Creating sections and headers...');
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    try {
                        sheet.name = "Income Statement";
                        await context.sync();
                    } catch (e) {}
                    
                    // Remove gridlines for cleaner look
                    try {
                        sheet.showGridlines = false;
                        await context.sync();
                    } catch (e) {
                        console.warn('Could not hide gridlines');
                    }
                    
                    let currentRow = 1;
                    
                    // ========== ROW 1-2: PARAMETERS ==========
                    // Title with dynamic year reference
                    const titleCell = sheet.getRange("A1");
                    titleCell.formulas = [['="Income Statement For: "&F2']];
                    await context.sync();
                    
                    try {
                        titleCell.format.font.bold = true;
                        titleCell.format.font.size = 18;
                        titleCell.format.font.color = "#09235C";
                        await context.sync();
                    } catch (e) {}
                    
                    // Parameters row
                    sheet.getRange("E2").values = [["YEAR"]];
                    sheet.getRange("F2").values = [[currentYear]];
                    sheet.getRange("H2").values = [["Subsidiary"]];
                    sheet.getRange("I2").values = [[defaultSubsidiary]];
                    await context.sync();
                    
                    // Style parameter inputs
                    try {
                        const yearInput = sheet.getRange("F2");
                        yearInput.format.fill.color = "#0AE2C1";
                        yearInput.format.font.bold = true;
                        yearInput.format.font.color = "#09235C";
                        
                        const subInput = sheet.getRange("I2");
                        subInput.format.fill.color = "#0AE2C1";
                        subInput.format.font.bold = true;
                        subInput.format.font.color = "#09235C";
                        
                        sheet.getRange("E2").format.font.bold = true;
                        sheet.getRange("E2").format.font.color = "#09235C";
                        sheet.getRange("H2").format.font.bold = true;
                        sheet.getRange("H2").format.font.color = "#09235C";
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 3: SYNC FLAG (Auto-generated marker) ==========
                    sheet.getRange("A3").values = [[" Structure Sync:"]];
                    sheet.getRange("B3").values = [["TRUE"]];
                    sheet.getRange("C3").values = [[" Change to FALSE if you customize this sheet"]];
                    await context.sync();
                    
                    // Style sync flag
                    try {
                        sheet.getRange("A3").format.font.bold = true;
                        sheet.getRange("A3").format.font.color = "#09235C";
                        sheet.getRange("A3").format.font.size = 10;
                        
                        // Sync value cell - teal like other inputs
                        const syncInput = sheet.getRange("B3");
                        syncInput.format.fill.color = "#0AE2C1";
                        syncInput.format.font.bold = true;
                        syncInput.format.font.color = "#09235C";
                        
                        // Help text - italic gray
                        sheet.getRange("C3").format.font.italic = true;
                        sheet.getRange("C3").format.font.color = "#6B7280";
                        sheet.getRange("C3").format.font.size = 9;
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 5: COLUMN HEADERS ==========
                    const headerRow = 5;
                    sheet.getRange("A5").values = [["Account #"]];
                    sheet.getRange("B5").values = [["Account Name"]];
                    
                    // Month headers with formula
                    for (let m = 0; m < 12; m++) {
                        const colLetter = String.fromCharCode(67 + m); // C=67
                        const cell = sheet.getRange(`${colLetter}5`);
                        cell.formulas = [[`=DATE($F$2,${m + 1},1)`]];
                    }
                    
                    // YTD column
                    sheet.getRange("O5").values = [["YTD Total"]];
                    await context.sync();
                    
                    // Format headers
                    try {
                        const headerRange = sheet.getRange("A5:O5");
                        headerRange.format.font.bold = true;
                        headerRange.format.font.color = "#FFFFFF";
                        headerRange.format.fill.color = "#09235C";
                        
                        const monthRange = sheet.getRange("C5:N5");
                        monthRange.numberFormat = [['mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm']];
                        await context.sync();
                    } catch (e) {}
                    
                    currentRow = 6;
                    
                    // Helper to write section header
                    const writeSectionHeader = async (text, row) => {
                        const cell = sheet.getRange(`A${row}`);
                        cell.values = [[text]];
                        await context.sync();
                        try {
                            const range = sheet.getRange(`A${row}:O${row}`);
                            range.format.font.bold = true;
                            range.format.font.color = "#09235C";
                            range.format.fill.color = "#E8EBF0";
                            await context.sync();
                        } catch (e) {}
                    };
                    
                    // Helper to write account row
                    const writeAccountRow = async (acct, row) => {
                        sheet.getRange(`A${row}`).values = [[acct.number]];
                        sheet.getRange(`B${row}`).values = [[acct.name]];
                        
                        // Balance formulas for each month (header row is now 5)
                        for (let m = 0; m < 12; m++) {
                            const colLetter = String.fromCharCode(67 + m);
                            const cell = sheet.getRange(`${colLetter}${row}`);
                            cell.formulas = [[`=XAVI.BALANCE($A${row},TEXT(${colLetter}$5,"mmm yyyy"),TEXT(${colLetter}$5,"mmm yyyy"),$I$2)`]];
                        }
                        
                        // YTD formula
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                    };
                    
                    // Helper to write subtotal row
                    const writeSubtotalRow = async (text, startRow, endRow, row, isBold = true) => {
                        sheet.getRange(`B${row}`).values = [[text]];
                        
                        // Sum formulas for each column
                        for (let m = 0; m < 12; m++) {
                            const colLetter = String.fromCharCode(67 + m);
                            sheet.getRange(`${colLetter}${row}`).formulas = [[`=SUM(${colLetter}${startRow}:${colLetter}${endRow})`]];
                        }
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                        
                        await context.sync();
                        
                        if (isBold) {
                            try {
                                const range = sheet.getRange(`A${row}:O${row}`);
                                range.format.font.bold = true;
                                // Add top border
                                range.format.borders.getItem('EdgeTop').style = 'Continuous';
                                await context.sync();
                            } catch (e) {}
                        }
                    };
                    
                    // Track row positions for calculations
                    let revenueStartRow, revenueEndRow, revenueTotalRow;
                    let cogsStartRow, cogsEndRow, cogsTotalRow;
                    let grossProfitRow;
                    let expenseStartRow, expenseEndRow, expenseTotalRow;
                    let operatingIncomeRow;
                    let othIncomeStartRow, othIncomeEndRow, othIncomeTotalRow;
                    let othExpenseStartRow, othExpenseEndRow, othExpenseTotalRow;
                    let netIncomeRow;
                    
                    updateProgress(50, ' Step 4 of 5: Writing Data', 'Adding Revenue accounts...');
                    
                    // ========== REVENUE SECTION ==========
                    if (categories.income.length > 0) {
                        await writeSectionHeader('REVENUE', currentRow);
                        currentRow++;
                        revenueStartRow = currentRow;
                        
                        for (const acct of categories.income) {
                            await writeAccountRow(acct, currentRow);
                            currentRow++;
                        }
                        revenueEndRow = currentRow - 1;
                        
                        await context.sync();
                        await writeSubtotalRow('Total Revenue', revenueStartRow, revenueEndRow, currentRow);
                        revenueTotalRow = currentRow;
                        currentRow += 2; // Blank row after
                    }
                    
                    updateProgress(60, ' Step 4 of 5: Writing Data', 'Adding Cost of Sales...');
                    
                    // ========== COST OF SALES SECTION ==========
                    if (categories.cogs.length > 0) {
                        await writeSectionHeader('COST OF SALES', currentRow);
                        currentRow++;
                        cogsStartRow = currentRow;
                        
                        for (const acct of categories.cogs) {
                            await writeAccountRow(acct, currentRow);
                            currentRow++;
                        }
                        cogsEndRow = currentRow - 1;
                        
                        await context.sync();
                        await writeSubtotalRow('Total Cost of Sales', cogsStartRow, cogsEndRow, currentRow);
                        cogsTotalRow = currentRow;
                        currentRow += 2;
                    }
                    
                    // ========== GROSS PROFIT ROW ==========
                    if (revenueTotalRow && cogsTotalRow) {
                        sheet.getRange(`B${currentRow}`).values = [['GROSS PROFIT']];
                        for (let m = 0; m < 12; m++) {
                            const colLetter = String.fromCharCode(67 + m);
                            sheet.getRange(`${colLetter}${currentRow}`).formulas = [[`=${colLetter}${revenueTotalRow}-${colLetter}${cogsTotalRow}`]];
                        }
                        sheet.getRange(`O${currentRow}`).formulas = [[`=SUM(C${currentRow}:N${currentRow})`]];
                        await context.sync();
                        
                        try {
                            const gpRange = sheet.getRange(`A${currentRow}:O${currentRow}`);
                            gpRange.format.font.bold = true;
                            gpRange.format.fill.color = "#D4E6F1";
                            gpRange.format.borders.getItem('EdgeTop').style = 'Double';
                            gpRange.format.borders.getItem('EdgeBottom').style = 'Continuous';
                            await context.sync();
                        } catch (e) {}
                        
                        grossProfitRow = currentRow;
                        currentRow += 2;
                    }
                    
                    updateProgress(70, ' Step 4 of 5: Writing Data', 'Adding Operating Expenses...');
                    
                    // ========== OPERATING EXPENSES SECTION ==========
                    if (categories.expense.length > 0) {
                        await writeSectionHeader('OPERATING EXPENSES', currentRow);
                        currentRow++;
                        expenseStartRow = currentRow;
                        
                        for (const acct of categories.expense) {
                            await writeAccountRow(acct, currentRow);
                            currentRow++;
                        }
                        expenseEndRow = currentRow - 1;
                        
                        await context.sync();
                        await writeSubtotalRow('Total Operating Expenses', expenseStartRow, expenseEndRow, currentRow);
                        expenseTotalRow = currentRow;
                        currentRow += 2;
                    }
                    
                    // ========== OPERATING INCOME ROW ==========
                    if (grossProfitRow && expenseTotalRow) {
                        sheet.getRange(`B${currentRow}`).values = [['OPERATING INCOME']];
                        for (let m = 0; m < 12; m++) {
                            const colLetter = String.fromCharCode(67 + m);
                            sheet.getRange(`${colLetter}${currentRow}`).formulas = [[`=${colLetter}${grossProfitRow}-${colLetter}${expenseTotalRow}`]];
                        }
                        sheet.getRange(`O${currentRow}`).formulas = [[`=SUM(C${currentRow}:N${currentRow})`]];
                        await context.sync();
                        
                        try {
                            const oiRange = sheet.getRange(`A${currentRow}:O${currentRow}`);
                            oiRange.format.font.bold = true;
                            oiRange.format.fill.color = "#D5F5E3";
                            oiRange.format.borders.getItem('EdgeTop').style = 'Continuous';
                            await context.sync();
                        } catch (e) {}
                        
                        operatingIncomeRow = currentRow;
                        currentRow += 2;
                    }
                    
                    updateProgress(80, ' Step 4 of 5: Writing Data', 'Adding Other Income/Expense...');
                    
                    // ========== OTHER INCOME SECTION ==========
                    if (categories.othIncome.length > 0) {
                        await writeSectionHeader('OTHER INCOME', currentRow);
                        currentRow++;
                        othIncomeStartRow = currentRow;
                        
                        for (const acct of categories.othIncome) {
                            await writeAccountRow(acct, currentRow);
                            currentRow++;
                        }
                        othIncomeEndRow = currentRow - 1;
                        
                        await context.sync();
                        await writeSubtotalRow('Total Other Income', othIncomeStartRow, othIncomeEndRow, currentRow);
                        othIncomeTotalRow = currentRow;
                        currentRow += 2;
                    }
                    
                    // ========== OTHER EXPENSE SECTION ==========
                    if (categories.othExpense.length > 0) {
                        await writeSectionHeader('OTHER EXPENSE', currentRow);
                        currentRow++;
                        othExpenseStartRow = currentRow;
                        
                        for (const acct of categories.othExpense) {
                            await writeAccountRow(acct, currentRow);
                            currentRow++;
                        }
                        othExpenseEndRow = currentRow - 1;
                        
                        await context.sync();
                        await writeSubtotalRow('Total Other Expense', othExpenseStartRow, othExpenseEndRow, currentRow);
                        othExpenseTotalRow = currentRow;
                        currentRow += 2;
                    }
                    
                    updateProgress(90, ' Step 4 of 5: Writing Data', 'Calculating Net Income...');
                    
                    // ========== NET INCOME ROW ==========
                    sheet.getRange(`B${currentRow}`).values = [['NET INCOME']];
                    
                    // Build NET INCOME formula: Operating Income + Other Income - Other Expense
                    for (let m = 0; m < 12; m++) {
                        const colLetter = String.fromCharCode(67 + m);
                        let formula = '=';
                        if (operatingIncomeRow) formula += `${colLetter}${operatingIncomeRow}`;
                        else if (grossProfitRow) formula += `${colLetter}${grossProfitRow}`;
                        else if (revenueTotalRow) formula += `${colLetter}${revenueTotalRow}`;
                        else formula += '0';
                        
                        if (othIncomeTotalRow) formula += `+${colLetter}${othIncomeTotalRow}`;
                        if (othExpenseTotalRow) formula += `-${colLetter}${othExpenseTotalRow}`;
                        
                        sheet.getRange(`${colLetter}${currentRow}`).formulas = [[formula]];
                    }
                    sheet.getRange(`O${currentRow}`).formulas = [[`=SUM(C${currentRow}:N${currentRow})`]];
                    await context.sync();
                    
                    try {
                        const niRange = sheet.getRange(`A${currentRow}:O${currentRow}`);
                        niRange.format.font.bold = true;
                        niRange.format.font.size = 12;
                        niRange.format.fill.color = "#09235C";
                        niRange.format.font.color = "#FFFFFF";
                        niRange.format.borders.getItem('EdgeTop').style = 'Double';
                        await context.sync();
                    } catch (e) {}
                    
                    netIncomeRow = currentRow;
                    
                    updateProgress(95, ' Step 5 of 5: Formatting', 'Applying number formats...');
                    
                    // Format all number cells as currency (data starts at row 6)
                    try {
                        const dataRange = sheet.getRange(`C6:O${netIncomeRow}`);
                        const rows = netIncomeRow - 5;
                        const cols = 13; // C through O
                        const formatArray = Array(rows).fill(null).map(() => Array(cols).fill('"$"#,##0'));
                        dataRange.numberFormat = formatArray;
                        await context.sync();
                    } catch (e) {
                        console.warn('Format warning:', e.message);
                    }
                    
                    // Freeze header rows (rows 1-5: title, params, sync flag, blank, headers)
                    try {
                        sheet.freezePanes.freezeRows(5);
                        await context.sync();
                    } catch (e) {}
                    
                    // Auto-fit columns
                    try {
                        sheet.getRange("A:O").format.autofitColumns();
                        await context.sync();
                    } catch (e) {}
                    
                    updateProgress(100, ' Complete!', 'Your Income Statement is ready!');
                });
                
                // Cleanup
                clearInterval(tipInterval);
                overlay.remove();
                
                // Success message
                const totalAccounts = categories.income.length + categories.othIncome.length + 
                                     categories.cogs.length + categories.expense.length + categories.othExpense.length;
                
                progress.style.display = 'block';
                progress.innerHTML = ` <strong>Income Statement Generated!</strong><br><br>
                    Created with <strong>${totalAccounts} accounts</strong> organized into sections:<br>
                     Revenue: ${categories.income.length} accounts<br>
                     Cost of Sales: ${categories.cogs.length} accounts<br>
                     Operating Expenses: ${categories.expense.length} accounts<br>
                     Other Income/Expense: ${categories.othIncome.length + categories.othExpense.length} accounts<br><br>
                    <div style="background: rgba(255, 193, 7, 0.2); padding: 10px 12px; border-radius: 8px; margin-bottom: 12px; border-left: 3px solid #FFC107;">
                         <strong>Please verify:</strong> This is auto-generated from your NetSuite data. 
                        Review account classifications and totals before using for official reporting.
                    </div>
                    <div style="background: rgba(10, 226, 193, 0.15); padding: 10px 12px; border-radius: 8px; margin-bottom: 12px; border-left: 3px solid var(--anenome);">
                         <strong>Change Year:</strong> Edit cell <strong>F2</strong> to a different year. The structure will automatically sync with accounts for that year.
                    </div>
                    <div style="background: rgba(10, 226, 193, 0.15); padding: 10px 12px; border-radius: 8px; border-left: 3px solid var(--anenome);">
                         <strong>Change Subsidiary:</strong> Navigate to cell <strong>I2</strong>, then use the <strong>Filters</strong> section in the task pane to select a different subsidiary.<br>
                        <span style="font-size: 11px; color: #6B7280; margin-top: 4px; display: block;">
                             The XAVI.BALANCE formula also supports <strong>Department</strong>, <strong>Class</strong>, and <strong>Location</strong> filtersadd these manually to customize your formulas.
                        </span>
                    </div>`;
                progress.style.lineHeight = '1.6';
                
                // Clear sync flag after successful generation
                isSyncInProgress = false;
                
            } catch (error) {
                console.error('Income Statement error:', error);
                clearInterval(tipInterval);
                if (document.getElementById('incomeStatementOverlay')) {
                    document.getElementById('incomeStatementOverlay').remove();
                }
                progress.style.display = 'block';
                progress.textContent = ` Error: ${error.message}`;
                
                // Clear sync flag on error too
                isSyncInProgress = false;
            }
        }

        // ================================================================
        // SYNC INCOME STATEMENT STRUCTURE FOR NEW YEAR
        // Only works on auto-generated sheets with Structure Sync = TRUE
        // ================================================================
        
        async function syncIncomeStatementStructure() {
            const statusEl = document.getElementById('refreshStatus');
            
            try {
                // Step 1: Check if current sheet has the sync flag
                let syncEnabled = false;
                let targetYear = new Date().getFullYear();
                let currentSubsidiary = '';
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Read A3 to check for sync marker
                    const markerCell = sheet.getRange("A3");
                    markerCell.load("values");
                    
                    // Read B3 for sync flag value
                    const syncCell = sheet.getRange("B3");
                    syncCell.load("values");
                    
                    // Read F2 for year
                    const yearCell = sheet.getRange("F2");
                    yearCell.load("values");
                    
                    // Read I2 for subsidiary
                    const subCell = sheet.getRange("I2");
                    subCell.load("values");
                    
                    await context.sync();
                    
                    const markerValue = String(markerCell.values[0][0] || '').toLowerCase();
                    const syncValue = String(syncCell.values[0][0] || '').toUpperCase();
                    const yearValue = yearCell.values[0][0];
                    const subValue = subCell.values[0][0];
                    
                    console.log('Sync check - Marker:', markerValue, 'Sync:', syncValue, 'Year:', yearValue);
                    
                    // Check if this is an auto-generated sheet
                    if (markerValue.includes('structure sync') || markerValue.includes('')) {
                        if (syncValue === 'TRUE' || syncValue === 'YES' || syncValue === '1') {
                            syncEnabled = true;
                            targetYear = parseInt(yearValue) || new Date().getFullYear();
                            currentSubsidiary = subValue || '';
                        } else {
                            // Sync is disabled
                            statusEl.innerHTML = `
                                <div style="background: #fef3c7; padding: 12px; border-radius: 8px; margin-top: 10px;">
                                    <strong style="color: #92400e;"> Structure Sync Disabled</strong><br>
                                    <span style="font-size: 12px; color: #78350f;">
                                        Cell B3 is set to "${syncValue}". Change it to TRUE to enable structure sync.
                                    </span>
                                </div>
                            `;
                            return;
                        }
                    } else {
                        // Not an auto-generated sheet
                        statusEl.innerHTML = `
                            <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px;">
                                <strong style="color: #dc2626;"> Not an Auto-Generated Sheet</strong><br>
                                <span style="font-size: 12px; color: #991b1b;">
                                    This feature only works on Income Statements created by "Full Income Statement" generator.
                                    The current sheet doesn't have the sync marker in cell A3.
                                </span>
                            </div>
                        `;
                        return;
                    }
                });
                
                if (!syncEnabled) {
                    return; // Message already shown above
                }
                
                // Step 2: Confirm with user
                const confirmed = confirm(
                    `Sync Structure for Year ${targetYear}?\n\n` +
                    `This will regenerate the Income Statement with all accounts that have data in ${targetYear}.\n\n` +
                    `Your YEAR and Subsidiary parameters will be preserved.\n\n` +
                    `Click OK to continue or Cancel to abort.`
                );
                
                if (!confirmed) {
                    statusEl.innerHTML = `
                        <div style="background: #f3f4f6; padding: 12px; border-radius: 8px; margin-top: 10px;">
                            <span style="color: #6b7280;">Sync cancelled.</span>
                        </div>
                    `;
                    return;
                }
                
                // Step 3: Show loading and regenerate
                statusEl.innerHTML = `
                    <div style="background: #dbeafe; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #1e40af;"> Syncing Structure...</strong><br>
                        <span style="font-size: 12px; color: #1e3a8a;">
                            Fetching accounts with data for ${targetYear}...
                        </span>
                    </div>
                `;
                
                // Fetch accounts for the target year
                const refreshResponse = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        year: targetYear,
                        subsidiary: '',
                        department: '',
                        location: '',
                        class: ''
                    })
                });
                
                if (!refreshResponse.ok) {
                    throw new Error(`Failed to load data: ${refreshResponse.status}`);
                }
                
                const refreshData = await refreshResponse.json();
                const allBalances = refreshData.balances || {};
                const accountTypes = refreshData.account_types || {};
                const accountNames = refreshData.account_names || {};
                
                // Categorize accounts
                const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                
                const categories = {
                    income: [], othIncome: [], cogs: [], expense: [], othExpense: []
                };
                
                for (const acctNum in allBalances) {
                    const monthData = allBalances[acctNum];
                    const hasData = Object.values(monthData).some(val => val !== 0 && val !== null);
                    
                    if (hasData) {
                        const acctInfo = {
                            number: acctNum,
                            name: accountNames[acctNum] || `Account ${acctNum}`,
                            type: accountTypes[acctNum] || 'Unknown'
                        };
                        
                        const acctType = (accountTypes[acctNum] || '').toLowerCase();
                        if (acctType === 'income') categories.income.push(acctInfo);
                        else if (acctType === 'othincome') categories.othIncome.push(acctInfo);
                        else if (acctType === 'cogs' || acctType === 'cost of goods sold') categories.cogs.push(acctInfo);
                        else if (acctType === 'expense') categories.expense.push(acctInfo);
                        else if (acctType === 'othexpense') categories.othExpense.push(acctInfo);
                    }
                }
                
                // Sort categories
                for (const cat in categories) {
                    categories[cat].sort((a, b) => a.number.localeCompare(b.number, undefined, {numeric: true}));
                }
                
                const totalAccounts = categories.income.length + categories.othIncome.length + 
                                     categories.cogs.length + categories.expense.length + categories.othExpense.length;
                
                statusEl.innerHTML = `
                    <div style="background: #dbeafe; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #1e40af;"> Rebuilding Sheet...</strong><br>
                        <span style="font-size: 12px; color: #1e3a8a;">
                            Found ${totalAccounts} accounts with data for ${targetYear}. Creating structure...
                        </span>
                    </div>
                `;
                
                // Step 4: Clear sheet and rebuild
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Clear existing content (keep name)
                    const usedRange = sheet.getUsedRange();
                    usedRange.clear();
                    await context.sync();
                    
                    let currentRow = 1;
                    
                    // ========== ROW 1: TITLE ==========
                    // Title with dynamic year reference
                    sheet.getRange("A1").formulas = [['="Income Statement For: "&F2']];
                    await context.sync();
                    try {
                        sheet.getRange("A1").format.font.bold = true;
                        sheet.getRange("A1").format.font.size = 18;
                        sheet.getRange("A1").format.font.color = "#09235C";
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 2: PARAMETERS ==========
                    sheet.getRange("E2").values = [["YEAR"]];
                    sheet.getRange("F2").values = [[targetYear]];
                    sheet.getRange("H2").values = [["Subsidiary"]];
                    sheet.getRange("I2").values = [[currentSubsidiary || 'Celigo Inc. (Consolidated)']];
                    await context.sync();
                    
                    try {
                        sheet.getRange("F2").format.fill.color = "#0AE2C1";
                        sheet.getRange("F2").format.font.bold = true;
                        sheet.getRange("I2").format.fill.color = "#0AE2C1";
                        sheet.getRange("I2").format.font.bold = true;
                        sheet.getRange("E2").format.font.bold = true;
                        sheet.getRange("H2").format.font.bold = true;
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 3: SYNC FLAG ==========
                    sheet.getRange("A3").values = [[" Structure Sync:"]];
                    sheet.getRange("B3").values = [["TRUE"]];
                    sheet.getRange("C3").values = [[" Change to FALSE if you customize this sheet"]];
                    await context.sync();
                    
                    try {
                        sheet.getRange("A3").format.font.bold = true;
                        sheet.getRange("B3").format.fill.color = "#0AE2C1";
                        sheet.getRange("B3").format.font.bold = true;
                        sheet.getRange("C3").format.font.italic = true;
                        sheet.getRange("C3").format.font.color = "#6B7280";
                        await context.sync();
                    } catch (e) {}
                    
                    // ========== ROW 5: HEADERS ==========
                    sheet.getRange("A5").values = [["Account #"]];
                    sheet.getRange("B5").values = [["Account Name"]];
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        sheet.getRange(`${col}5`).formulas = [[`=DATE($F$2,${m + 1},1)`]];
                    }
                    sheet.getRange("O5").values = [["YTD Total"]];
                    await context.sync();
                    
                    try {
                        sheet.getRange("A5:O5").format.font.bold = true;
                        sheet.getRange("A5:O5").format.font.color = "#FFFFFF";
                        sheet.getRange("A5:O5").format.fill.color = "#09235C";
                        sheet.getRange("C5:N5").numberFormat = [['mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm']];
                        await context.sync();
                    } catch (e) {}
                    
                    currentRow = 6;
                    
                    // Helper functions (same as generate)
                    const writeSectionHeader = async (text, row) => {
                        sheet.getRange(`A${row}`).values = [[text]];
                        await context.sync();
                        try {
                            sheet.getRange(`A${row}:O${row}`).format.font.bold = true;
                            sheet.getRange(`A${row}:O${row}`).format.fill.color = "#E8EBF0";
                            await context.sync();
                        } catch (e) {}
                    };
                    
                    const writeAccountRow = (acct, row) => {
                        sheet.getRange(`A${row}`).values = [[acct.number]];
                        sheet.getRange(`B${row}`).values = [[acct.name]];
                        for (let m = 0; m < 12; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${row}`).formulas = [[`=XAVI.BALANCE($A${row},TEXT(${col}$5,"mmm yyyy"),TEXT(${col}$5,"mmm yyyy"),$I$2)`]];
                        }
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                    };
                    
                    const writeSubtotalRow = async (text, startRow, endRow, row) => {
                        sheet.getRange(`B${row}`).values = [[text]];
                        for (let m = 0; m < 12; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${row}`).formulas = [[`=SUM(${col}${startRow}:${col}${endRow})`]];
                        }
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                        await context.sync();
                        try {
                            sheet.getRange(`A${row}:O${row}`).format.font.bold = true;
                            sheet.getRange(`A${row}:O${row}`).format.borders.getItem('EdgeTop').style = 'Continuous';
                            await context.sync();
                        } catch (e) {}
                    };
                    
                    let revenueTotalRow, cogsTotalRow, grossProfitRow, expenseTotalRow, operatingIncomeRow;
                    let othIncomeTotalRow, othExpenseTotalRow, netIncomeRow;
                    
                    // REVENUE
                    if (categories.income.length > 0) {
                        await writeSectionHeader('REVENUE', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.income) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Revenue', startRow, currentRow - 1, currentRow);
                        revenueTotalRow = currentRow++;
                        currentRow++; // blank
                    }
                    
                    // COGS
                    if (categories.cogs.length > 0) {
                        await writeSectionHeader('COST OF SALES', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.cogs) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Cost of Sales', startRow, currentRow - 1, currentRow);
                        cogsTotalRow = currentRow++;
                        currentRow++;
                    }
                    
                    // GROSS PROFIT
                    if (revenueTotalRow && cogsTotalRow) {
                        sheet.getRange(`B${currentRow}`).values = [['GROSS PROFIT']];
                        for (let m = 0; m < 12; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${currentRow}`).formulas = [[`=${col}${revenueTotalRow}-${col}${cogsTotalRow}`]];
                        }
                        sheet.getRange(`O${currentRow}`).formulas = [[`=SUM(C${currentRow}:N${currentRow})`]];
                        await context.sync();
                        try {
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#D4E6F1";
                            await context.sync();
                        } catch (e) {}
                        grossProfitRow = currentRow++;
                        currentRow++;
                    }
                    
                    // OPERATING EXPENSES
                    if (categories.expense.length > 0) {
                        await writeSectionHeader('OPERATING EXPENSES', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.expense) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Operating Expenses', startRow, currentRow - 1, currentRow);
                        expenseTotalRow = currentRow++;
                        currentRow++;
                    }
                    
                    // OPERATING INCOME
                    if (grossProfitRow && expenseTotalRow) {
                        sheet.getRange(`B${currentRow}`).values = [['OPERATING INCOME']];
                        for (let m = 0; m < 12; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${currentRow}`).formulas = [[`=${col}${grossProfitRow}-${col}${expenseTotalRow}`]];
                        }
                        sheet.getRange(`O${currentRow}`).formulas = [[`=SUM(C${currentRow}:N${currentRow})`]];
                        await context.sync();
                        try {
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#D5F5E3";
                            await context.sync();
                        } catch (e) {}
                        operatingIncomeRow = currentRow++;
                        currentRow++;
                    }
                    
                    // OTHER INCOME
                    if (categories.othIncome.length > 0) {
                        await writeSectionHeader('OTHER INCOME', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.othIncome) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Other Income', startRow, currentRow - 1, currentRow);
                        othIncomeTotalRow = currentRow++;
                        currentRow++;
                    }
                    
                    // OTHER EXPENSE
                    if (categories.othExpense.length > 0) {
                        await writeSectionHeader('OTHER EXPENSE', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.othExpense) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Other Expense', startRow, currentRow - 1, currentRow);
                        othExpenseTotalRow = currentRow++;
                        currentRow++;
                    }
                    
                    // NET INCOME
                    sheet.getRange(`B${currentRow}`).values = [['NET INCOME']];
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        let formula = '=';
                        if (operatingIncomeRow) formula += `${col}${operatingIncomeRow}`;
                        else if (grossProfitRow) formula += `${col}${grossProfitRow}`;
                        else if (revenueTotalRow) formula += `${col}${revenueTotalRow}`;
                        else formula += '0';
                        if (othIncomeTotalRow) formula += `+${col}${othIncomeTotalRow}`;
                        if (othExpenseTotalRow) formula += `-${col}${othExpenseTotalRow}`;
                        sheet.getRange(`${col}${currentRow}`).formulas = [[formula]];
                    }
                    sheet.getRange(`O${currentRow}`).formulas = [[`=SUM(C${currentRow}:N${currentRow})`]];
                    await context.sync();
                    
                    try {
                        sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                        sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#09235C";
                        sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.color = "#FFFFFF";
                        await context.sync();
                    } catch (e) {}
                    netIncomeRow = currentRow;
                    
                    // Format numbers
                    try {
                        const rows = netIncomeRow - 5;
                        const formatArray = Array(rows).fill(null).map(() => Array(13).fill('"$"#,##0'));
                        sheet.getRange(`C6:O${netIncomeRow}`).numberFormat = formatArray;
                        await context.sync();
                    } catch (e) {}
                    
                    // Freeze
                    try {
                        sheet.freezePanes.freezeRows(5);
                        await context.sync();
                    } catch (e) {}
                });
                
                // Success
                statusEl.innerHTML = `
                    <div style="background: #d1fae5; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #065f46;"> Structure Synced!</strong><br>
                        <span style="font-size: 12px; color: #047857;">
                            Rebuilt Income Statement for ${targetYear} with ${totalAccounts} accounts.
                        </span>
                    </div>
                `;
                
            } catch (error) {
                console.error('Sync error:', error);
                statusEl.innerHTML = `
                    <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #dc2626;"> Sync Failed</strong><br>
                        <span style="font-size: 12px; color: #991b1b;">${error.message}</span>
                    </div>
                `;
            }
        }

        // ================================================================
        // PRE-LOAD SHEET DATA - Cache data for selected date range
        // ================================================================

        function dismissPreload() {
            document.getElementById('preloadCard').classList.add('preload-hidden');
            localStorage.setItem('preloadDismissed', 'true');
        }

        function showPreload() {
            if (localStorage.getItem('preloadDismissed') !== 'true') {
                document.getElementById('preloadCard').classList.remove('preload-hidden');
            }
        }

        async function runPreloadSheet() {
            const btn = document.getElementById('preloadBtn');
            const btnText = document.getElementById('preloadBtnText');
            const progress = document.getElementById('preloadProgress');
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            // Excel History Facts - shown during loading
            const excelHistory = [
                { year: '1985', fact: 'Excel 1.0 was released for Mac  before Windows even existed! Microsoft saw the Mac as the future of computing.' },
                { year: '1987', fact: 'Excel came to Windows, two years after Mac. There was no Windows Excel 1.0  it started at version 2.0!' },
                { year: '1988', fact: 'Excel 2.0 introduced the toolbar, revolutionizing how users interacted with spreadsheet commands.' },
                { year: '1990', fact: 'Excel 3.0 added 3D charts, drawing tools, and the ability to link worksheets  a game-changer for finance teams.' },
                { year: '1992', fact: 'Excel 4.0 introduced XLM macros, the predecessor to VBA. Some companies still use them today!' },
                { year: '1993', fact: 'Excel 5.0 brought VBA (Visual Basic for Applications), transforming Excel from a spreadsheet into a programming platform.' },
                { year: '1995', fact: 'Excel 95 was the first 32-bit version, bundled with Office 95 for Windows 95  the birth of modern Office.' },
                { year: '1997', fact: 'Excel 97 could handle 65,536 rows  4x more than before. Finance teams rejoiced!' },
                { year: '1998-2001', fact: 'Excel for Mac was discontinued for 3 years! Mac users had to use Virtual PC to run Windows Excel.' },
                { year: '2003', fact: 'Excel 2003 introduced XML data import and improved list functionality  early steps toward Power Query.' },
                { year: '2007', fact: 'Excel 2007 expanded to 1,048,576 rows (1 million+) and introduced the ribbon interface that we still use today.' },
                { year: '2010', fact: 'Excel Web App launched  the first time you could edit spreadsheets in a browser. Collaboration was born.' },
                { year: '2013', fact: 'Excel 2013 added Flash Fill  automatic pattern recognition that feels like magic. Try it!' },
                { year: '2016', fact: 'Power Query was integrated directly into Excel, making data transformation accessible to everyone.' },
                { year: '2019', fact: 'XLOOKUP finally arrived! After 35+ years, VLOOKUP got a worthy successor with backwards lookup capability.' },
                { year: '2020', fact: 'Dynamic arrays were introduced  formulas that automatically spill results into adjacent cells. Revolutionary!' },
                { year: '2023', fact: 'Excel added Python support! You can now write Python code directly in cells alongside your formulas.' },
                { year: 'Fun Fact', fact: 'The name "Excel" was originally trademarked by another company. Microsoft had to license it!' },
                { year: 'Fun Fact', fact: 'The $ symbol for absolute references ($A$1) has been used since Lotus 1-2-3 in 1983.' },
                { year: 'Fun Fact', fact: 'Excel can calculate faster than you think  it processes about 1 billion cells per second on modern hardware.' }
            ];
            let historyIndex = 0;

            btn.disabled = true;
            btnText.textContent = 'Reading selection...';
            
            // CRITICAL: Signal formulas to wait via localStorage
            // This works across contexts (taskpane iframe  custom functions)
            console.log('Pre-load: Setting preload status via localStorage');
            try {
                localStorage.setItem('netsuite_preload_status', 'running');
                localStorage.setItem('netsuite_preload_timestamp', Date.now().toString());
                console.log('Pre-load:  Preload status set - formulas will wait');
            } catch (e) {
                console.warn('Pre-load:  Could not set preload status:', e);
            }

            try {
                // Step 1: Read selected range from Excel and build period strings
                let selectedPeriods = [];  // ["Dec 2024", "Jan 2025", ...]
                let selectedYears = new Set();

                await Excel.run(async (context) => {
                    const range = context.workbook.getSelectedRange();
                    range.load(['values', 'valueTypes']);
                    await context.sync();

                    const values = range.values;
                    console.log('Pre-load: Selected range values:', values);

                    // Parse dates from the selection
                    for (const row of values) {
                        for (const cell of row) {
                            let dateValue = null;

                            // Handle different date formats
                            if (typeof cell === 'number' && cell > 0) {
                                // Excel serial date number
                                const excelEpoch = new Date(1899, 11, 30);
                                dateValue = new Date(excelEpoch.getTime() + cell * 86400000);
                            } else if (typeof cell === 'string') {
                                // Try to parse string as date
                                const parsed = new Date(cell);
                                if (!isNaN(parsed.getTime())) {
                                    dateValue = parsed;
                                }
                                // Also try "Mon YYYY" format
                                const monthYearMatch = cell.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d{4})$/i);
                                if (monthYearMatch) {
                                    const monthIndex = monthNames.findIndex(m => m.toLowerCase() === monthYearMatch[1].toLowerCase());
                                    if (monthIndex !== -1) {
                                        dateValue = new Date(parseInt(monthYearMatch[2]), monthIndex, 1);
                                    }
                                }
                            } else if (cell instanceof Date) {
                                dateValue = cell;
                            }

                            if (dateValue && !isNaN(dateValue.getTime())) {
                                const year = dateValue.getFullYear();
                                const month = dateValue.getMonth();
                                if (year >= 2000 && year <= 2100) { // Reasonable year range
                                    // Convert to period string like "Dec 2024"
                                    const periodStr = `${monthNames[month]} ${year}`;
                                    if (!selectedPeriods.includes(periodStr)) {
                                        selectedPeriods.push(periodStr);
                                    }
                                    selectedYears.add(year);
                                }
                            }
                        }
                    }
                });

                if (selectedPeriods.length === 0) {
                    throw new Error('No valid dates found in selection. Please select cells containing dates (e.g., 1/1/2025 or "Jan 2025").');
                }

                // Sort periods chronologically
                selectedPeriods.sort((a, b) => {
                    const [aMonth, aYear] = a.split(' ');
                    const [bMonth, bYear] = b.split(' ');
                    const aIdx = monthNames.indexOf(aMonth) + parseInt(aYear) * 12;
                    const bIdx = monthNames.indexOf(bMonth) + parseInt(bYear) * 12;
                    return aIdx - bIdx;
                });

                const yearsArray = Array.from(selectedYears).sort();
                console.log('Pre-load: Detected periods:', selectedPeriods);
                console.log('Pre-load: Years spanned:', yearsArray);

                // Estimate time based on periods (not full years!)
                const periodCount = selectedPeriods.length;
                const estimatedTime = periodCount <= 4 ? '30-45 seconds' : 
                                     periodCount <= 8 ? '45-60 seconds' : 
                                     periodCount <= 13 ? '60-90 seconds' : '90-120 seconds';

                // Create and show loading overlay
                const overlay = document.createElement('div');
                overlay.className = 'preload-overlay';
                overlay.id = 'preloadOverlay';
                overlay.innerHTML = `
                    <div class="loading-spinner"></div>
                    <h2>Pre-loading ${periodCount} Periods</h2>
                    <div class="loading-subtitle" style="max-width: 320px; margin-bottom: 24px;">
                         Estimated time: <strong>${estimatedTime}</strong><br>
                        <span style="opacity: 0.7; font-size: 12px;">(Much faster than loading ${yearsArray.length * 12} months from full years!)</span>
                    </div>
                    
                    <div class="progress-container" style="max-width: 320px; margin-bottom: 20px;">
                        <div class="progress-bar-bg" style="background: rgba(255,255,255,0.2); border-radius: 4px; overflow: hidden;">
                            <div class="progress-bar-fill" id="preloadProgressBar" style="height: 8px; background: linear-gradient(90deg, #7dffb3, #4ade80); width: 0%;"></div>
                        </div>
                        <div class="progress-text" id="preloadProgressText" style="font-size: 12px; opacity: 0.7; margin-top: 8px;">0% complete</div>
                    </div>
                    
                    <div class="loading-step" id="preloadStep" style="color: #7dffb3; font-weight: 600;">Connecting to NetSuite...</div>
                    <div class="loading-step-desc" id="preloadStepDesc" style="font-size: 12px; opacity: 0.7; margin-top: 6px; max-width: 300px;">
                        Loading: ${selectedPeriods.slice(0, 3).join(', ')}${selectedPeriods.length > 3 ? ` + ${selectedPeriods.length - 3} more` : ''}
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); border-radius: 10px; padding: 14px; margin-top: 24px; max-width: 320px; text-align: left;">
                        <div style="font-size: 11px; text-transform: uppercase; letter-spacing: 1px; opacity: 0.6; margin-bottom: 4px;"> Why the wait?</div>
                        <div style="font-size: 12px; line-height: 1.5; opacity: 0.85;">
                            Balance Sheet accounts are calculated from the <strong>beginning of time</strong>  every transaction ever recorded affects the balance. This one-time load saves minutes later!
                        </div>
                    </div>
                    
                    <div class="history-section">
                        <div class="history-label"> Excel History</div>
                        <div class="history-year" id="preloadHistoryYear">${excelHistory[0].year}</div>
                        <div class="history-fact" id="preloadHistoryFact">${excelHistory[0].fact}</div>
                    </div>
                `;
                document.body.appendChild(overlay);

                // Rotate history facts every 4 seconds
                const historyInterval = setInterval(() => {
                    historyIndex = (historyIndex + 1) % excelHistory.length;
                    const yearEl = document.getElementById('preloadHistoryYear');
                    const factEl = document.getElementById('preloadHistoryFact');
                    if (yearEl && factEl) {
                        factEl.style.opacity = '0';
                        setTimeout(() => {
                            yearEl.textContent = excelHistory[historyIndex].year;
                            factEl.textContent = excelHistory[historyIndex].fact;
                            factEl.style.opacity = '1';
                        }, 200);
                    }
                }, 4000);

                const updateProgress = (percent, step, desc) => {
                    const bar = document.getElementById('preloadProgressBar');
                    const text = document.getElementById('preloadProgressText');
                    const stepEl = document.getElementById('preloadStep');
                    const descEl = document.getElementById('preloadStepDesc');
                    if (bar) bar.style.width = percent + '%';
                    if (text) text.textContent = percent + '% complete';
                    if (stepEl) stepEl.textContent = step;
                    if (descEl) descEl.textContent = desc;
                };

                // Step 2: Load data for specific periods only (optimized!)
                let allBalances = {};
                let allTypes = {};
                let allNames = {};
                
                updateProgress(5, ' Loading Data', `Fetching ${periodCount} periods for all accounts...`);
                
                // Use full_year_refresh for each year (same as formulas - works within timeout!)
                // This is more reliable than periods_refresh which can timeout on Cloudflare
                const yearsList = Array.from(selectedYears).sort();
                let yearProgress = 5;
                const progressPerYear = Math.floor(75 / yearsList.length);
                
                try {
                    for (let i = 0; i < yearsList.length; i++) {
                        const year = yearsList[i];
                        updateProgress(yearProgress, ' Loading Data', 
                            `Loading year ${year} (${i + 1}/${yearsList.length})...`);
                        
                        console.log(`Pre-load: Fetching year ${year}...`);
                        const startTime = Date.now();
                        
                        const response = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                                year: parseInt(year),
                            subsidiary: '',
                            department: '',
                            location: '',
                                class: '',
                                skip_bs: true  // FAST MODE: Skip BS accounts (load on-demand)
                        })
                    });

                    if (!response.ok) {
                            throw new Error(`Failed to load year ${year}: ${response.status}`);
                    }

                    const data = await response.json();
                        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                        const yearBalances = data.balances || {};
                        const accountCount = Object.keys(yearBalances).length;
                        
                        console.log(`Pre-load: Year ${year} loaded - ${accountCount} accounts in ${elapsed}s`);
                        
                        // Merge into allBalances
                        for (const acct in yearBalances) {
                            if (!allBalances[acct]) allBalances[acct] = {};
                            for (const period in yearBalances[acct]) {
                                allBalances[acct][period] = yearBalances[acct][period];
                            }
                        }
                        
                        // Merge types if available
                        if (data.account_types) {
                            Object.assign(allTypes, data.account_types);
                        }
                        
                        yearProgress += progressPerYear;
                    }
                    
                    console.log(`Pre-load: Total loaded - ${Object.keys(allBalances).length} accounts`);

                    // Fill in $0 for requested periods that have no data
                    for (const acctNum in allBalances) {
                        for (const period of selectedPeriods) {
                            if (allBalances[acctNum][period] === undefined) {
                                allBalances[acctNum][period] = 0;
                            }
                        }
                    }
                    
                    // Fetch account names if not already loaded
                    updateProgress(85, ' Loading Names', 'Fetching account names...');
                    try {
                        const namesResponse = await fetch(`${SERVER_URL}/account/preload_titles`);
                        if (namesResponse.ok) {
                            const namesData = await namesResponse.json();
                            allNames = namesData.titles || {};
                            console.log(`Pre-load: Loaded ${Object.keys(allNames).length} account names`);
                        }
                    } catch (namesError) {
                        console.warn('Pre-load: Could not fetch account names:', namesError.message);
                    }

                } catch (fetchError) {
                    console.error('Pre-load fetch error:', fetchError);
                    throw fetchError;
                }

                updateProgress(92, ' Preparing Data', 'Getting everything ready for fast analysis...');

                // Save to localStorage
                try {
                    const existingBalances = JSON.parse(localStorage.getItem('netsuite_balance_cache') || '{}');
                    const mergedBalances = { ...existingBalances };
                    
                    // Merge new balances with existing (overwrite same periods)
                    for (const acctNum in allBalances) {
                        if (!mergedBalances[acctNum]) {
                            mergedBalances[acctNum] = {};
                        }
                        Object.assign(mergedBalances[acctNum], allBalances[acctNum]);
                    }

                    const cacheJson = JSON.stringify(mergedBalances);
                    console.log('Pre-load: Saving to localStorage...');
                    console.log(`   Accounts: ${Object.keys(mergedBalances).length}`);
                    console.log(`   Sample accounts: ${Object.keys(mergedBalances).slice(0, 5).join(', ')}`);
                    console.log(`   Data size: ${cacheJson.length} chars`);
                    
                    localStorage.setItem('netsuite_balance_cache', cacheJson);
                    localStorage.setItem('netsuite_balance_cache_timestamp', Date.now().toString());
                    
                    // Verify it was saved
                    const verifyTimestamp = localStorage.getItem('netsuite_balance_cache_timestamp');
                    const verifyData = localStorage.getItem('netsuite_balance_cache');
                    console.log('Pre-load: Verification after save:');
                    console.log(`   Timestamp saved: ${verifyTimestamp}`);
                    console.log(`   Data saved: ${verifyData ? verifyData.length + ' chars' : 'NULL!'}`);
                    
                    if (mergedBalances['10010']) {
                        console.log(`   Account 10010 periods: ${Object.keys(mergedBalances['10010']).join(', ')}`);
                    }
                    
                    // Merge and save types
                    const existingTypes = JSON.parse(localStorage.getItem('netsuite_type_cache') || '{}');
                    localStorage.setItem('netsuite_type_cache', JSON.stringify({ ...existingTypes, ...allTypes }));
                    
                    // Merge and save names
                    const existingNames = JSON.parse(localStorage.getItem('netsuite_name_cache') || '{}');
                    localStorage.setItem('netsuite_name_cache', JSON.stringify({ ...existingNames, ...allNames }));

                    console.log('Pre-load: Saved all data to localStorage');

                    // Populate in-memory caches
                    console.log('Pre-load: Populating caches...');
                    console.log('   typeof window.setFullYearCache:', typeof window.setFullYearCache);
                    
                    if (typeof window.setFullYearCache === 'function') {
                        console.log('Pre-load:  Calling setFullYearCache with', Object.keys(mergedBalances).length, 'accounts');
                        window.setFullYearCache(mergedBalances);
                    } else {
                        console.log('Pre-load:  window.setFullYearCache NOT AVAILABLE');
                    }
                    if (typeof window.setAccountTypeCache === 'function') {
                        window.setAccountTypeCache({ ...existingTypes, ...allTypes });
                    }
                    if (typeof window.setAccountNameCache === 'function') {
                        window.setAccountNameCache({ ...existingNames, ...allNames });
                    }
                    
                    // CRITICAL: Signal formulas that preload is complete via localStorage
                    console.log('Pre-load:  Setting preload status to complete');
                    localStorage.setItem('netsuite_preload_status', 'complete');
                } catch (cacheError) {
                    console.warn('Pre-load: Cache save warning:', cacheError);
                    // Still finish preload even if cache save fails
                    localStorage.setItem('netsuite_preload_status', 'complete');
                }

                updateProgress(100, ' P&L Complete!', 'Income/Expense accounts ready!');

                // Clean up overlay
                clearInterval(historyInterval);
                setTimeout(() => overlay.remove(), 500);
                    
                // Check if user wants Balance Sheet accounts too
                const includeBS = document.getElementById('includeBSCheckbox')?.checked || false;
                    const accountCount = Object.keys(allBalances).length;
                    
                // Show P&L success message
                    progress.style.display = 'block';
                
                if (includeBS) {
                    // Show P&L done, BS loading message
                    progress.innerHTML = ` <strong>P&L accounts ready!</strong> (${accountCount} accounts)<br><br>
                        <div style="background: rgba(10, 226, 193, 0.15); padding: 10px 12px; border-radius: 8px; border-left: 3px solid var(--anenome);">
                             <strong>Loading Balance Sheet...</strong><br>
                            <span style="font-size: 11px;">Cash, AR, AP, etc.  this takes 2-3 minutes</span><br>
                            <span id="bsLoadingStatus" style="font-size: 11px; color: var(--chrome);">Starting...</span>
                        </div>
                        <div style="font-size: 11px; color: #888; margin-top: 8px;">
                             Start entering P&L formulas now  they'll resolve instantly!
                        </div>`;
                    progress.style.lineHeight = '1.6';
                    btnText.textContent = ' Loading BS...';
                    btn.style.background = 'var(--tidal-wave)';
                    
                    // Start BS loading in background
                    loadBalanceSheetInBackground(uniqueYears, progress, btn, btnText);
                } else {
                    // P&L only - show final success message
                    progress.innerHTML = ` <strong>You're all set!</strong><br><br>
                        <strong>${accountCount}</strong> Income/Expense accounts loaded<br>
                        <span style="font-size: 11px; color: #666;">${selectedPeriods.slice(0, 4).join(', ')}${selectedPeriods.length > 4 ? ` + ${selectedPeriods.length - 4} more` : ''}</span><br><br>
                        <div style="background: rgba(125, 255, 179, 0.15); padding: 10px 12px; border-radius: 8px; border-left: 3px solid #7dffb3;">
                             <strong>P&L accounts</strong> = instant results
                        </div>
                        <div style="font-size: 11px; color: #888; margin-top: 8px;">
                             Need Balance Sheet? Check the box above and reload.
                        </div>`;
                    progress.style.lineHeight = '1.6';
                    btnText.textContent = ' Ready!';
                    btn.style.background = '#4CAF50';
                    btn.disabled = false;
                }

            } catch (error) {
                console.error('Pre-load error:', error);
                // Release any waiting formulas on error via localStorage
                localStorage.setItem('netsuite_preload_status', 'error');
                
                if (document.getElementById('preloadOverlay')) {
                    document.getElementById('preloadOverlay').remove();
                }
                
                // Provide user-friendly error messages
                let errorMessage = error.message;
                let helpTip = '';
                
                if (error.message.includes('524') || error.message.includes('timeout')) {
                    errorMessage = 'Request timed out';
                    helpTip = `<div style="font-size: 11px; margin-top: 8px; color: #666;">
                        <strong>Why this happens:</strong> NetSuite queries for Balance Sheet accounts can take several minutes. 
                        <strong>Try this:</strong> Your formulas will still work - they'll load data on-demand when you enter them.
                    </div>`;
                } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    errorMessage = 'Could not reach server';
                    helpTip = `<div style="font-size: 11px; margin-top: 8px; color: #666;">
                        Check that the server is running and the tunnel URL is correct in your settings.
                    </div>`;
                } else if (error.message.includes('No valid dates')) {
                    helpTip = `<div style="font-size: 11px; margin-top: 8px; color: #666;">
                        Select cells containing dates like "Jan 2025" or "1/1/2025" before clicking this button.
                    </div>`;
                }
                
                progress.style.display = 'block';
                progress.innerHTML = `<div style="color: #ff6b6b;"> ${errorMessage}</div>${helpTip}`;
                btnText.textContent = 'Try Again';
                btn.disabled = false;
                btn.style.background = '';
            }
        }

        // Background Balance Sheet loading - runs after P&L is complete
        async function loadBalanceSheetInBackground(years, progressEl, btn, btnText) {
            console.log(' Starting background Balance Sheet loading for years:', years);
            const statusEl = document.getElementById('bsLoadingStatus');
            
            try {
                let totalBSAccounts = 0;
                
                for (let i = 0; i < years.length; i++) {
                    const year = years[i];
                    if (statusEl) {
                        statusEl.textContent = `Loading ${year}... (${i + 1}/${years.length} years)`;
                    }
                    
                    console.log(` Fetching BS data for ${year}...`);
                    const startTime = Date.now();
                    
                    const response = await fetch(`${SERVER_URL}/batch/full_year_refresh_bs`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            year: parseInt(year),
                            subsidiary: '',
                            department: '',
                            location: '',
                            class: ''
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`BS load failed: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                    console.log(` BS ${year}: ${Object.keys(data.balances || {}).length} accounts in ${elapsed}s`);
                    
                    // Merge BS data into localStorage cache
                    const existingBalances = JSON.parse(localStorage.getItem('netsuite_balance_cache') || '{}');
                    for (const [account, periods] of Object.entries(data.balances || {})) {
                        if (!existingBalances[account]) {
                            existingBalances[account] = {};
                        }
                        Object.assign(existingBalances[account], periods);
                        totalBSAccounts++;
                    }
                    localStorage.setItem('netsuite_balance_cache', JSON.stringify(existingBalances));
                    localStorage.setItem('netsuite_balance_timestamp', Date.now().toString());
                    
                    // Update fullYearCache if available
                    if (typeof window.setFullYearCache === 'function') {
                        window.setFullYearCache(existingBalances);
                    }
                }
                
                // Success!
                console.log(` Background BS loading complete: ${totalBSAccounts} accounts`);
                
                progressEl.innerHTML = ` <strong>All accounts ready!</strong><br><br>
                    <div style="background: rgba(125, 255, 179, 0.15); padding: 10px 12px; border-radius: 8px; border-left: 3px solid #7dffb3;">
                         <strong>P&L accounts</strong> = instant<br>
                         <strong>Balance Sheet</strong> = instant (${totalBSAccounts} accounts)
                    </div>
                    <div style="font-size: 11px; color: #888; margin-top: 8px;">
                        All formulas will resolve instantly!
                    </div>`;
                
                btnText.textContent = ' All Ready!';
                btn.style.background = '#4CAF50';
                btn.disabled = false;
                
            } catch (error) {
                console.error(' Background BS loading error:', error);
                
                progressEl.innerHTML = ` <strong>P&L accounts ready!</strong><br><br>
                    <div style="background: rgba(255, 107, 107, 0.15); padding: 10px 12px; border-radius: 8px; border-left: 3px solid #ff6b6b;">
                         <strong>Balance Sheet loading failed</strong><br>
                        <span style="font-size: 11px;">${error.message}</span>
                    </div>
                    <div style="font-size: 11px; color: #888; margin-top: 8px;">
                        P&L formulas work instantly. BS formulas will load on-demand (~45s each).
                    </div>`;
                
                btnText.textContent = ' P&L Ready';
                btn.style.background = '#4CAF50';
                btn.disabled = false;
            }
        }

        async function checkServerStatus() {
            const statusEl = document.getElementById('serverStatus');
            statusEl.className = 'status-indicator checking';
            statusEl.innerHTML = '<span class="status-dot checking"></span> Checking...';

            try {
                const response = await fetch(`${SERVER_URL}/health`, { 
                    method: 'GET',
                    signal: AbortSignal.timeout(10000)
                });
                
                if (response.ok) {
                    statusEl.className = 'status-indicator connected';
                    statusEl.innerHTML = '<span class="status-dot connected"></span> Connected ';
                } else {
                    throw new Error(`Status: ${response.status}`);
                }
            } catch (error) {
                statusEl.className = 'status-indicator error';
                statusEl.innerHTML = `<span class="status-dot error"></span> Error: ${error.message}`;
            }
        }

        async function restartServer() {
            const statusEl = document.getElementById('serverStatus');
            
            if (!confirm('Restart the backend server? This will briefly interrupt connections.')) {
                return;
            }
            
            statusEl.className = 'status-indicator checking';
            statusEl.innerHTML = '<span class="status-dot checking"></span> Restarting...';
            
            // Show toast notification
            const toastId = showToast({
                title: 'Restarting Server',
                message: 'Sending restart command...',
                type: 'calculating',
                duration: 0 // Don't auto-dismiss
            });
            
            try {
                const response = await fetch(`${SERVER_URL}/admin/restart`, { 
                    method: 'POST',
                    signal: AbortSignal.timeout(10000)
                });
                
                if (response.ok) {
                    statusEl.innerHTML = '<span class="status-dot checking"></span> Server restarting...';
                    updateToast(toastId, { message: 'Server is restarting...' });
                }
            } catch (error) {
                // Connection error is expected during restart
                console.log('Restart request sent (connection dropped as expected)');
            }
            
                statusEl.innerHTML = '<span class="status-dot checking"></span> Waiting for restart...';
            updateToast(toastId, { message: 'Waiting for server to come back online...' });
                
                // Keep checking until server is back
                let attempts = 0;
                const checkInterval = setInterval(async () => {
                    attempts++;
                    try {
                        const healthResponse = await fetch(`${SERVER_URL}/health`, { 
                            method: 'GET',
                            signal: AbortSignal.timeout(3000)
                        });
                        if (healthResponse.ok) {
                            clearInterval(checkInterval);
                            statusEl.className = 'status-indicator connected';
                            statusEl.innerHTML = '<span class="status-dot connected"></span> Restarted ';
                        
                        // Fetch and display tunnel URL
                        try {
                            const infoResponse = await fetch(`${SERVER_URL}/`, { 
                                method: 'GET',
                                signal: AbortSignal.timeout(3000)
                            });
                            if (infoResponse.ok) {
                                const data = await infoResponse.json();
                                // Update toast with success and show server info
                                updateToast(toastId, {
                                    title: 'Server Restarted',
                                    message: `Server is back online!<br><br><strong>Local:</strong> http://localhost:5002<br><strong>Note:</strong> Cloudflare tunnel URL may have changed. Check terminal or run tunnel command.`,
                                    type: 'success'
                                });
                                // Auto-dismiss after 8 seconds
                                setTimeout(() => removeToast(toastId), 8000);
                            }
                        } catch (e) {
                            updateToast(toastId, {
                                title: 'Server Restarted',
                                message: 'Server is back online!',
                                type: 'success'
                            });
                            setTimeout(() => removeToast(toastId), 5000);
                        }
                        }
                    } catch (e) {
                        if (attempts > 10) {
                            clearInterval(checkInterval);
                            statusEl.className = 'status-indicator error';
                            statusEl.innerHTML = '<span class="status-dot error"></span> Restart failed - check terminal';
                        
                        updateToast(toastId, {
                            title: 'Restart Failed',
                            message: 'Could not connect to server after restart. Check the terminal for errors.',
                            type: 'error'
                        });
                        setTimeout(() => removeToast(toastId), 8000);
                        }
                    }
                }, 2000);
        }

        function copyTunnelCommand() {
            const command = 'pkill cloudflared; cloudflared tunnel --url http://localhost:5002';
            navigator.clipboard.writeText(command).then(() => {
                alert('Command copied! Paste in Terminal to restart tunnel.');
            }).catch(err => {
                prompt('Copy this command:', command);
            });
        }

        function copyWorkerCode() {
            const newUrl = document.getElementById('newTunnelUrl').value.trim();
            if (!newUrl || !newUrl.includes('trycloudflare.com')) {
                alert('Please paste the new tunnel URL first (e.g., https://xxx.trycloudflare.com)');
                return;
            }
            
            const workerCode = `// Cloudflare Worker - NetSuite Proxy
// Updated: ${new Date().toISOString()}
const TUNNEL_URL = '${newUrl}';

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const targetUrl = TUNNEL_URL + url.pathname + url.search;
    
    // Handle CORS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type',
          'Access-Control-Max-Age': '86400',
        },
      });
    }
    
    try {
      const response = await fetch(targetUrl, {
        method: request.method,
        headers: request.headers,
        body: request.method !== 'GET' ? await request.text() : undefined,
      });
      
      const newResponse = new Response(response.body, response);
      newResponse.headers.set('Access-Control-Allow-Origin', '*');
      return newResponse;
    } catch (error) {
      return new Response(JSON.stringify({ error: error.message }), {
        status: 502,
        headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' },
      });
    }
  },
};`;
            
            navigator.clipboard.writeText(workerCode).then(() => {
                alert('Worker code copied with new tunnel URL!\\n\\nGo to Cloudflare Dashboard  Workers  netsuite-proxy  Edit Code  Paste  Deploy');
            }).catch(err => {
                // Fallback for browsers that don't support clipboard
                const textarea = document.createElement('textarea');
                textarea.value = workerCode;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert('Worker code copied!');
            });
        }

        async function reloadLookups() {
            const statusEl = document.getElementById('serverStatus');
            statusEl.className = 'status-indicator checking';
            statusEl.innerHTML = '<span class="status-dot checking"></span> Reloading lookups...';
            
            try {
                await loadNetSuiteLookups();
                await preloadAccountTitles();
                statusEl.className = 'status-indicator connected';
                statusEl.innerHTML = '<span class="status-dot connected"></span> Lookups reloaded ';
            } catch (error) {
                statusEl.className = 'status-indicator error';
                statusEl.innerHTML = `<span class="status-dot error"></span> Failed: ${error.message}`;
            }
        }

        async function checkTunnelStatus() {
            const statusEl = document.getElementById('tunnelStatus');
            statusEl.className = 'status-indicator checking';
            statusEl.innerHTML = '<span class="status-dot checking"></span> Checking...';

            try {
                // The health check goes through the worker  tunnel  server
                // If it works, tunnel is working
                const response = await fetch(`${SERVER_URL}/health`, { 
                    method: 'GET',
                    signal: AbortSignal.timeout(10000)
                });
                
                if (response.ok) {
                    statusEl.className = 'status-indicator connected';
                    statusEl.innerHTML = '<span class="status-dot connected"></span> Tunnel Active ';
                } else if (response.status === 530) {
                    throw new Error('Tunnel offline (530)');
                } else {
                    throw new Error(`Status: ${response.status}`);
                }
            } catch (error) {
                statusEl.className = 'status-indicator error';
                if (error.message.includes('530')) {
                    statusEl.innerHTML = '<span class="status-dot error"></span> Tunnel Offline - needs restart';
                } else {
                    statusEl.innerHTML = `<span class="status-dot error"></span> ${error.message}`;
                }
            }
        }

        function checkCacheStatus() {
            try {
                const STORAGE_KEY = 'netsuite_balance_cache';
                const STORAGE_TIMESTAMP_KEY = 'netsuite_balance_cache_timestamp';
                
                const cached = localStorage.getItem(STORAGE_KEY);
                const timestamp = localStorage.getItem(STORAGE_TIMESTAMP_KEY);
                
                const localStorageEl = document.getElementById('localStorageStatus');
                const accountsEl = document.getElementById('cachedAccountsCount');
                
                if (cached && timestamp) {
                    const balances = JSON.parse(cached);
                    const accountCount = Object.keys(balances).length;
                    const cacheAge = Math.round((Date.now() - parseInt(timestamp)) / 1000);
                    
                    localStorageEl.textContent = `Active (${cacheAge}s ago)`;
                    localStorageEl.style.color = '#059669';
                    accountsEl.textContent = `${accountCount} accounts`;
                } else {
                    localStorageEl.textContent = 'Empty';
                    localStorageEl.style.color = '#6b7280';
                    accountsEl.textContent = '0';
                }
            } catch (e) {
                document.getElementById('localStorageStatus').textContent = 'Error';
                document.getElementById('cachedAccountsCount').textContent = '-';
            }
        }

        function copyTunnelInstructions() {
            const urlInput = document.getElementById('newTunnelUrl');
            const url = urlInput.value.trim();
            
            if (!url) {
                alert('Please enter the new tunnel URL first');
                return;
            }
            
            const workerCode = `const TUNNEL_URL = '${url}';`;
            navigator.clipboard.writeText(workerCode).then(() => {
                alert('Copied! Paste this in the Cloudflare Worker to update the tunnel URL.');
            }).catch(() => {
                prompt('Copy this line to update the Worker:', workerCode);
            });
        }

        // Load NetSuite lookups into dropdowns
        async function loadNetSuiteLookups() {
            const statusEl = document.getElementById('lookupStatus');
            statusEl.textContent = 'Loading NetSuite filters...';
            statusEl.style.color = '#0284c7';
            
            try {
                const response = await fetch(`${SERVER_URL}/lookups/all`);
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Lookups loaded:', data);
                
                // Populate subsidiary dropdown - Show NAMES only (backend converts to IDs)
                const subSelect = document.getElementById('subsidiarySelect');
                subSelect.innerHTML = '<option value="">-- All (No Filter) --</option>';
                (data.subsidiaries || []).forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.name;  // Use NAME as value (backend converts)
                    option.textContent = item.name;  // Show NAME only
                    subSelect.appendChild(option);
                });
                
                // Populate department dropdown - Show NAMES only
                const deptSelect = document.getElementById('departmentSelect');
                deptSelect.innerHTML = '<option value="">-- All (No Filter) --</option>';
                (data.departments || []).forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.name;  // Use NAME as value (backend converts)
                    option.textContent = item.name;  // Show NAME only
                    deptSelect.appendChild(option);
                });
                
                // Populate class dropdown - Show NAMES only
                const classSelect = document.getElementById('classSelect');
                classSelect.innerHTML = '<option value="">-- All (No Filter) --</option>';
                (data.classes || []).forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.name;  // Use NAME as value (backend converts)
                    option.textContent = item.name;  // Show NAME only
                    classSelect.appendChild(option);
                });
                
                // Populate location dropdown - Show NAMES only
                const locSelect = document.getElementById('locationSelect');
                locSelect.innerHTML = '<option value="">-- All (No Filter) --</option>';
                (data.locations || []).forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.name;  // Use NAME as value (backend converts)
                    option.textContent = item.name;  // Show NAME only
                    locSelect.appendChild(option);
                });
                
                // Populate accounting book dropdown - Show NAMES, use IDs as values
                // Multi-Book Accounting: Primary Book, Secondary Books (GAAP, IFRS, Tax, etc.)
                // Note: value="1" is the Primary Book ID in NetSuite
                const bookSelect = document.getElementById('accountingBookSelect');
                bookSelect.innerHTML = '<option value="1">Primary Book (Default)</option>';
                (data.accountingBooks || []).forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.id;  // Use ID as value (backend expects numeric ID)
                    option.textContent = item.name;  // Show name (includes "(Primary)" marker)
                    bookSelect.appendChild(option);
                });
                
                statusEl.textContent = ' Lookup lists loaded!';
                statusEl.style.color = '#059669';
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 3000);
                
            } catch (error) {
                console.error('Error loading lookups:', error);
                statusEl.textContent = ' Error loading lookups: ' + error.message;
                statusEl.style.color = '#dc2626';
            }
        }

        // Insert lookup value into selected cell
        async function insertLookupValue(type) {
            const statusEl = document.getElementById('lookupStatus');
            
            try {
                let selectId, typeName;
                if (type === 'subsidiary') {
                    selectId = 'subsidiarySelect';
                    typeName = 'Subsidiary';
                } else if (type === 'department') {
                    selectId = 'departmentSelect';
                    typeName = 'Department';
                } else if (type === 'class') {
                    selectId = 'classSelect';
                    typeName = 'Class';
                } else if (type === 'location') {
                    selectId = 'locationSelect';
                    typeName = 'Location';
                } else if (type === 'accountingBook') {
                    selectId = 'accountingBookSelect';
                    typeName = 'Accounting Book';
                }
                
                const select = document.getElementById(selectId);
                const selectedValue = select.value;
                
                await Excel.run(async (context) => {
                    const range = context.workbook.getSelectedRange();
                    
                    // Insert the value (NAME for most filters, ID for accounting book)
                    range.values = [[selectedValue]];
                    await context.sync();
                    
                    if (selectedValue === '') {
                        statusEl.textContent = ` Inserted: All ${typeName}s (no filter)`;
                    } else if (type === 'accountingBook') {
                        // For accounting book, show the selected text not the ID
                        const selectedText = select.options[select.selectedIndex].text;
                        statusEl.textContent = ` Inserted ${typeName} ID: ${selectedValue} (${selectedText})`;
                    } else {
                        statusEl.textContent = ` Inserted ${typeName}: "${selectedValue}"`;
                    }
                    statusEl.style.color = '#059669';
                    
                    setTimeout(() => {
                        statusEl.textContent = '';
                    }, 3000);
                });
                
            } catch (error) {
                console.error('Error inserting value:', error);
                statusEl.textContent = ' Error: ' + error.message;
                statusEl.style.color = '#dc2626';
            }
        }

        // Create a hidden lookup sheet with Name  ID mappings
        async function createLookupSheet() {
            const statusEl = document.getElementById('lookupSheetStatus');
            statusEl.textContent = 'Creating lookup sheet...';
            statusEl.style.color = '#0284c7';
            
            try {
                // First, fetch the lookup data
                const response = await fetch(`${SERVER_URL}/lookups/all`);
                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Lookups data:', data);
                
                await Excel.run(async (context) => {
                    // Check if sheet exists, delete if it does
                    const sheets = context.workbook.worksheets;
                    sheets.load('items/name');
                    await context.sync();
                    
                    const existingSheet = sheets.items.find(s => s.name === 'NSLookups');
                    if (existingSheet) {
                        existingSheet.delete();
                        await context.sync();
                    }
                    
                    // Create new hidden sheet
                    const lookupSheet = sheets.add('NSLookups');
                    lookupSheet.visibility = Excel.SheetVisibility.hidden;
                    
                    let currentRow = 1;
                    
                    // Add Subsidiaries section
                    lookupSheet.getRange(`A${currentRow}`).values = [['SUBSIDIARIES']];
                    lookupSheet.getRange(`A${currentRow}`).format.font.bold = true;
                    currentRow++;
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [['Name', 'ID']];
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).format.font.bold = true;
                    currentRow++;
                    
                    const subStart = currentRow;
                    (data.subsidiaries || []).forEach(item => {
                        lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [[item.name, item.id]];
                        currentRow++;
                    });
                    const subEnd = currentRow - 1;
                    
                    // Define named range for subsidiaries
                    if (data.subsidiaries && data.subsidiaries.length > 0) {
                        context.workbook.names.add(`SubsidiaryLookup`, lookupSheet.getRange(`A${subStart}:B${subEnd}`));
                    }
                    
                    currentRow++; // Empty row
                    
                    // Add Departments section
                    lookupSheet.getRange(`A${currentRow}`).values = [['DEPARTMENTS']];
                    lookupSheet.getRange(`A${currentRow}`).format.font.bold = true;
                    currentRow++;
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [['Name', 'ID']];
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).format.font.bold = true;
                    currentRow++;
                    
                    const deptStart = currentRow;
                    (data.departments || []).forEach(item => {
                        lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [[item.name, item.id]];
                        currentRow++;
                    });
                    const deptEnd = currentRow - 1;
                    
                    if (data.departments && data.departments.length > 0) {
                        context.workbook.names.add(`DepartmentLookup`, lookupSheet.getRange(`A${deptStart}:B${deptEnd}`));
                    }
                    
                    currentRow++; // Empty row
                    
                    // Add Classes section
                    lookupSheet.getRange(`A${currentRow}`).values = [['CLASSES']];
                    lookupSheet.getRange(`A${currentRow}`).format.font.bold = true;
                    currentRow++;
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [['Name', 'ID']];
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).format.font.bold = true;
                    currentRow++;
                    
                    const classStart = currentRow;
                    (data.classes || []).forEach(item => {
                        lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [[item.name, item.id]];
                        currentRow++;
                    });
                    const classEnd = currentRow - 1;
                    
                    if (data.classes && data.classes.length > 0) {
                        context.workbook.names.add(`ClassLookup`, lookupSheet.getRange(`A${classStart}:B${classEnd}`));
                    }
                    
                    currentRow++; // Empty row
                    
                    // Add Locations section
                    lookupSheet.getRange(`A${currentRow}`).values = [['LOCATIONS']];
                    lookupSheet.getRange(`A${currentRow}`).format.font.bold = true;
                    currentRow++;
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [['Name', 'ID']];
                    lookupSheet.getRange(`A${currentRow}:B${currentRow}`).format.font.bold = true;
                    currentRow++;
                    
                    const locStart = currentRow;
                    (data.locations || []).forEach(item => {
                        lookupSheet.getRange(`A${currentRow}:B${currentRow}`).values = [[item.name, item.id]];
                        currentRow++;
                    });
                    const locEnd = currentRow - 1;
                    
                    if (data.locations && data.locations.length > 0) {
                        context.workbook.names.add(`LocationLookup`, lookupSheet.getRange(`A${locStart}:B${locEnd}`));
                    }
                    
                    // Auto-size columns
                    lookupSheet.getRange('A:B').format.autofitColumns();
                    
                    await context.sync();
                    
                    statusEl.innerHTML = ` Lookup sheet created!<br><small style="color: #1e40af;">Type names like "Hardware" or "Boston" in cells.<br>Use XLOOKUP to convert to IDs in formulas.</small>`;
                    statusEl.style.color = '#059669';
                });
                
            } catch (error) {
                console.error('Error creating lookup sheet:', error);
                statusEl.textContent = ' Error: ' + error.message;
                statusEl.style.color = '#dc2626';
            }
        }

        Office.onReady((info) => {
            console.log('NetSuite Excel Add-in task pane loaded');
            
            // Set version in UI elements
            initializeVersion();
            
            // Start connection monitoring (checks every 60 seconds)
            startConnectionMonitor();
            
            // Auto-load lookups on open
            loadNetSuiteLookups();
            
            // CRITICAL: Preload ALL account titles to prevent 429 rate limit errors
            // This makes ONE query instead of 150+ concurrent queries
            preloadAccountTitles();
            
            // Handle Quick Start accordion for first-time users
            initializeQuickStart();
            
            // Set up worksheet change listener for auto-sync
            setupAutoSyncListener();
        });
        
        // Initialize Quick Start section - expanded for first-time users, collapsed for returning users
        function initializeQuickStart() {
            const quickStartSection = document.getElementById('quickStartSection');
            const isReturningUser = localStorage.getItem('xavi_returning_user') === 'true';
            
            if (isReturningUser) {
                // Returning user - collapse the Quick Start section
                quickStartSection.removeAttribute('open');
                console.log('Returning user - Quick Start collapsed');
            } else {
                // First time user - keep it open (already open by default)
                console.log('First-time user - Quick Start expanded');
                // Mark as returning user for next time
                localStorage.setItem('xavi_returning_user', 'true');
            }
        }
        
        // Set up listener to auto-sync Income Statement when YEAR changes
        async function setupAutoSyncListener() {
            try {
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Register for changes on the worksheet
                    sheet.onChanged.add(async (event) => {
                        // Check if the changed cell is F2 (YEAR parameter)
                        if (event.address === 'F2' || event.address === '$F$2') {
                            console.log(' YEAR cell (F2) changed - checking for auto-sync...');
                            await handleYearChange();
                        }
                    });
                    
                    await context.sync();
                    console.log(' Auto-sync listener registered for worksheet changes');
                });
            } catch (e) {
                console.warn('Could not set up auto-sync listener:', e.message);
            }
        }
        
        // Flag to prevent re-entry during sync operations
        let isSyncInProgress = false;
        let lastSyncedYear = null;
        
        // Handle automatic structure sync when YEAR changes
        async function handleYearChange() {
            // Prevent infinite loop - don't sync if already syncing
            if (isSyncInProgress) {
                console.log(' Sync already in progress, skipping...');
                return;
            }
            
            try {
                let shouldSync = false;
                let newYear = null;
                let subsidiary = '';
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Check for sync marker
                    const markerCell = sheet.getRange("A3");
                    markerCell.load("values");
                    const syncCell = sheet.getRange("B3");
                    syncCell.load("values");
                    const yearCell = sheet.getRange("F2");
                    yearCell.load("values");
                    const subCell = sheet.getRange("I2");
                    subCell.load("values");
                    
                    await context.sync();
                    
                    const marker = String(markerCell.values[0][0] || '').toLowerCase();
                    const sync = String(syncCell.values[0][0] || '').toUpperCase();
                    newYear = parseInt(yearCell.values[0][0]) || new Date().getFullYear();
                    
                    // Only sync if: has marker, sync enabled, AND year actually changed
                    if ((marker.includes('structure sync') || marker.includes('')) &&
                        (sync === 'TRUE' || sync === 'YES' || sync === '1') &&
                        newYear !== lastSyncedYear) {
                        shouldSync = true;
                        subsidiary = subCell.values[0][0] || '';
                    }
                });
                
                if (shouldSync && newYear) {
                    console.log(` Auto-syncing structure for year ${newYear}...`);
                    
                    // Set flag to prevent re-entry
                    isSyncInProgress = true;
                    lastSyncedYear = newYear;
                    
                    // Show a brief notification
                    const statusEl = document.getElementById('refreshStatus');
                    if (statusEl) {
                        statusEl.innerHTML = `<div style="background: #dbeafe; padding: 10px; border-radius: 6px; border-left: 4px solid #3b82f6;">
                            <strong style="color: #1e40af;"> Syncing for ${newYear}...</strong><br>
                            <small style="color: #1e3a8a;">Rebuilding structure with accounts for ${newYear}</small>
                        </div>`;
                    }
                    
                    try {
                        // Trigger the sync
                        await performStructureSync(newYear, subsidiary);
                    } finally {
                        // Always clear the flag when done
                        isSyncInProgress = false;
                    }
                }
            } catch (e) {
                console.warn('Auto-sync error:', e.message);
                isSyncInProgress = false; // Clear flag on error
            }
        }
        
        // Perform the structure sync (extracted for reuse)
        async function performStructureSync(targetYear, currentSubsidiary) {
            const statusEl = document.getElementById('refreshStatus');
            
            try {
                // Fetch accounts for the target year
                const refreshResponse = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        year: targetYear,
                        subsidiary: '',
                        department: '',
                        location: '',
                        class: ''
                    })
                });
                
                if (!refreshResponse.ok) {
                    throw new Error(`Failed to load data: ${refreshResponse.status}`);
                }
                
                const refreshData = await refreshResponse.json();
                const allBalances = refreshData.balances || {};
                const accountTypes = refreshData.account_types || {};
                const accountNames = refreshData.account_names || {};
                
                // Categorize accounts
                const categories = {
                    income: [], othIncome: [], cogs: [], expense: [], othExpense: []
                };
                
                for (const acctNum in allBalances) {
                    const monthData = allBalances[acctNum];
                    const hasData = Object.values(monthData).some(val => val !== 0 && val !== null);
                    
                    if (hasData) {
                        const acctInfo = {
                            number: acctNum,
                            name: accountNames[acctNum] || `Account ${acctNum}`,
                            type: accountTypes[acctNum] || 'Unknown'
                        };
                        
                        const acctType = (accountTypes[acctNum] || '').toLowerCase();
                        if (acctType === 'income') categories.income.push(acctInfo);
                        else if (acctType === 'othincome') categories.othIncome.push(acctInfo);
                        else if (acctType === 'cogs' || acctType === 'cost of goods sold') categories.cogs.push(acctInfo);
                        else if (acctType === 'expense') categories.expense.push(acctInfo);
                        else if (acctType === 'othexpense') categories.othExpense.push(acctInfo);
                    }
                }
                
                // Sort categories
                for (const cat in categories) {
                    categories[cat].sort((a, b) => a.number.localeCompare(b.number, undefined, {numeric: true}));
                }
                
                const totalAccounts = categories.income.length + categories.othIncome.length + 
                                     categories.cogs.length + categories.expense.length + categories.othExpense.length;
                
                // Rebuild the sheet
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    const usedRange = sheet.getUsedRange();
                    usedRange.clear();
                    await context.sync();
                    
                    try { sheet.showGridlines = false; await context.sync(); } catch (e) {}
                    
                    // ROW 1: TITLE
                    sheet.getRange("A1").formulas = [['="Income Statement For: "&F2']];
                    await context.sync();
                    try {
                        sheet.getRange("A1").format.font.bold = true;
                        sheet.getRange("A1").format.font.size = 18;
                        sheet.getRange("A1").format.font.color = "#09235C";
                        await context.sync();
                    } catch (e) {}
                    
                    // ROW 2: PARAMETERS
                    sheet.getRange("E2").values = [["YEAR"]];
                    sheet.getRange("F2").values = [[targetYear]];
                    sheet.getRange("H2").values = [["Subsidiary"]];
                    sheet.getRange("I2").values = [[currentSubsidiary || 'Celigo Inc. (Consolidated)']];
                    await context.sync();
                    
                    try {
                        sheet.getRange("F2").format.fill.color = "#0AE2C1";
                        sheet.getRange("F2").format.font.bold = true;
                        sheet.getRange("I2").format.fill.color = "#0AE2C1";
                        sheet.getRange("I2").format.font.bold = true;
                        sheet.getRange("E2").format.font.bold = true;
                        sheet.getRange("H2").format.font.bold = true;
                        await context.sync();
                    } catch (e) {}
                    
                    // ROW 3: SYNC FLAG
                    sheet.getRange("A3").values = [[" Structure Sync:"]];
                    sheet.getRange("B3").values = [["TRUE"]];
                    sheet.getRange("C3").values = [[" Change to FALSE if you customize this sheet"]];
                    await context.sync();
                    
                    try {
                        sheet.getRange("A3").format.font.bold = true;
                        sheet.getRange("B3").format.fill.color = "#0AE2C1";
                        sheet.getRange("B3").format.font.bold = true;
                        sheet.getRange("C3").format.font.italic = true;
                        sheet.getRange("C3").format.font.color = "#6B7280";
                        await context.sync();
                    } catch (e) {}
                    
                    // ROW 5: HEADERS
                    sheet.getRange("A5").values = [["Account #"]];
                    sheet.getRange("B5").values = [["Account Name"]];
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        sheet.getRange(`${col}5`).formulas = [[`=DATE($F$2,${m + 1},1)`]];
                    }
                    sheet.getRange("O5").values = [["YTD Total"]];
                    await context.sync();
                    
                    try {
                        sheet.getRange("A5:O5").format.font.bold = true;
                        sheet.getRange("A5:O5").format.font.color = "#FFFFFF";
                        sheet.getRange("A5:O5").format.fill.color = "#09235C";
                        sheet.getRange("C5:N5").numberFormat = [['mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm']];
                        await context.sync();
                    } catch (e) {}
                    
                    let currentRow = 6;
                    
                    const writeSectionHeader = async (text, row) => {
                        sheet.getRange(`A${row}`).values = [[text]];
                        await context.sync();
                        try {
                            sheet.getRange(`A${row}:O${row}`).format.font.bold = true;
                            sheet.getRange(`A${row}:O${row}`).format.fill.color = "#E8EBF0";
                            await context.sync();
                        } catch (e) {}
                    };
                    
                    const writeAccountRow = (acct, row) => {
                        sheet.getRange(`A${row}`).values = [[acct.number]];
                        sheet.getRange(`B${row}`).values = [[acct.name]];
                        for (let m = 0; m < 12; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${row}`).formulas = [[`=XAVI.BALANCE($A${row},TEXT(${col}$5,"mmm yyyy"),TEXT(${col}$5,"mmm yyyy"),$I$2)`]];
                        }
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                    };
                    
                    const writeSubtotalRow = async (text, startRow, endRow, row) => {
                        sheet.getRange(`B${row}`).values = [[text]];
                        for (let m = 0; m < 12; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${row}`).formulas = [[`=SUM(${col}${startRow}:${col}${endRow})`]];
                        }
                        sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                        await context.sync();
                        try {
                            sheet.getRange(`A${row}:O${row}`).format.font.bold = true;
                            sheet.getRange(`A${row}:O${row}`).format.borders.getItem('EdgeTop').style = 'Continuous';
                            await context.sync();
                        } catch (e) {}
                    };
                    
                    let revenueTotalRow, cogsTotalRow, grossProfitRow, expenseTotalRow, operatingIncomeRow;
                    let othIncomeTotalRow, othExpenseTotalRow, netIncomeRow;
                    
                    if (categories.income.length > 0) {
                        await writeSectionHeader('REVENUE', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.income) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Revenue', startRow, currentRow - 1, currentRow);
                        revenueTotalRow = currentRow++;
                        currentRow++;
                    }
                    
                    if (categories.cogs.length > 0) {
                        await writeSectionHeader('COST OF SALES', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.cogs) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Cost of Sales', startRow, currentRow - 1, currentRow);
                        cogsTotalRow = currentRow++;
                        currentRow++;
                    }
                    
                    if (revenueTotalRow && cogsTotalRow) {
                        sheet.getRange(`B${currentRow}`).values = [['GROSS PROFIT']];
                        for (let m = 0; m < 12; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${currentRow}`).formulas = [[`=${col}${revenueTotalRow}-${col}${cogsTotalRow}`]];
                        }
                        sheet.getRange(`O${currentRow}`).formulas = [[`=SUM(C${currentRow}:N${currentRow})`]];
                        await context.sync();
                        try {
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#D4E6F1";
                            await context.sync();
                        } catch (e) {}
                        grossProfitRow = currentRow++;
                        currentRow++;
                    }
                    
                    if (categories.expense.length > 0) {
                        await writeSectionHeader('OPERATING EXPENSES', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.expense) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Operating Expenses', startRow, currentRow - 1, currentRow);
                        expenseTotalRow = currentRow++;
                        currentRow++;
                    }
                    
                    if (grossProfitRow && expenseTotalRow) {
                        sheet.getRange(`B${currentRow}`).values = [['OPERATING INCOME']];
                        for (let m = 0; m < 12; m++) {
                            const col = String.fromCharCode(67 + m);
                            sheet.getRange(`${col}${currentRow}`).formulas = [[`=${col}${grossProfitRow}-${col}${expenseTotalRow}`]];
                        }
                        sheet.getRange(`O${currentRow}`).formulas = [[`=SUM(C${currentRow}:N${currentRow})`]];
                        await context.sync();
                        try {
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                            sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#D5F5E3";
                            await context.sync();
                        } catch (e) {}
                        operatingIncomeRow = currentRow++;
                        currentRow++;
                    }
                    
                    if (categories.othIncome.length > 0) {
                        await writeSectionHeader('OTHER INCOME', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.othIncome) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Other Income', startRow, currentRow - 1, currentRow);
                        othIncomeTotalRow = currentRow++;
                        currentRow++;
                    }
                    
                    if (categories.othExpense.length > 0) {
                        await writeSectionHeader('OTHER EXPENSE', currentRow++);
                        const startRow = currentRow;
                        for (const acct of categories.othExpense) writeAccountRow(acct, currentRow++);
                        await context.sync();
                        await writeSubtotalRow('Total Other Expense', startRow, currentRow - 1, currentRow);
                        othExpenseTotalRow = currentRow++;
                        currentRow++;
                    }
                    
                    sheet.getRange(`B${currentRow}`).values = [['NET INCOME']];
                    for (let m = 0; m < 12; m++) {
                        const col = String.fromCharCode(67 + m);
                        let formula = '=';
                        if (operatingIncomeRow) formula += `${col}${operatingIncomeRow}`;
                        else if (grossProfitRow) formula += `${col}${grossProfitRow}`;
                        else if (revenueTotalRow) formula += `${col}${revenueTotalRow}`;
                        else formula += '0';
                        if (othIncomeTotalRow) formula += `+${col}${othIncomeTotalRow}`;
                        if (othExpenseTotalRow) formula += `-${col}${othExpenseTotalRow}`;
                        sheet.getRange(`${col}${currentRow}`).formulas = [[formula]];
                    }
                    sheet.getRange(`O${currentRow}`).formulas = [[`=SUM(C${currentRow}:N${currentRow})`]];
                    await context.sync();
                    
                    try {
                        sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                        sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#09235C";
                        sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.color = "#FFFFFF";
                        await context.sync();
                    } catch (e) {}
                    netIncomeRow = currentRow;
                    
                    try {
                        const rows = netIncomeRow - 5;
                        const formatArray = Array(rows).fill(null).map(() => Array(13).fill('"$"#,##0'));
                        sheet.getRange(`C6:O${netIncomeRow}`).numberFormat = formatArray;
                        await context.sync();
                    } catch (e) {}
                    
                    try { sheet.freezePanes.freezeRows(5); await context.sync(); } catch (e) {}
                });
                
                // Success message
                if (statusEl) {
                    statusEl.innerHTML = `<div style="background: #d1fae5; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #065f46;"> Structure Synced for ${targetYear}</strong><br>
                        <span style="font-size: 12px; color: #047857;">
                            Rebuilt with ${totalAccounts} accounts. Formulas will resolve shortly.
                        </span>
                        <div style="margin-top: 10px; padding: 10px; background: rgba(10, 226, 193, 0.15); border-radius: 6px; border-left: 3px solid #0AE2C1;">
                            <strong style="font-size: 11px; color: #09235C;"> Filtering Tips:</strong>
                            <ul style="margin: 6px 0 0 16px; font-size: 11px; color: #374151; line-height: 1.5;">
                                <li><strong>Subsidiary:</strong> Navigate to cell <strong>I2</strong>, then use the <strong>Filters</strong> section in the task pane to select a different subsidiary.</li>
                                <li><strong>More filters:</strong> The XAVI.BALANCE formula also supports <strong>Department</strong>, <strong>Class</strong>, and <strong>Location</strong> parametersyou can add these manually to your formulas.</li>
                            </ul>
                        </div>
                    </div>`;
                }
                
                console.log(` Auto-sync complete for ${targetYear}`);
                
            } catch (error) {
                console.error('Structure sync error:', error);
                if (statusEl) {
                    statusEl.innerHTML = `<div style="background: #fee2e2; padding: 10px; border-radius: 6px;">
                        <strong style="color: #dc2626;">Sync Error:</strong> ${error.message}
                    </div>`;
                }
            }
        }
        
        async function preloadAccountTitles() {
            try {
                console.log(' Preloading account titles...');
                const response = await fetch(`${SERVER_URL}/account/preload_titles`);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log(` Preloaded ${data.loaded} account titles`);
                } else {
                    console.warn('  Failed to preload account titles:', response.status);
                }
            } catch (error) {
                console.error('Error preloading account titles:', error);
                // Don't throw - taskpane should still work even if preload fails
            }
        }

        async function clearCache() {
            const statusEl = document.getElementById('refreshStatus');
            const btn = event.target;
            
            try {
                btn.disabled = true;
                btn.textContent = 'Clearing...';
                
                showLoading('Clear Cache', 'Clearing all cached data...', 20);
                
                // STEP 1: Clear localStorage (shared across all contexts)
                console.log(' CLEAR CACHE: Clearing localStorage...');
                try {
                    localStorage.removeItem('netsuite_balance_cache');
                    localStorage.removeItem('netsuite_balance_cache_timestamp');
                    localStorage.removeItem('netsuite_preload_status');
                    localStorage.removeItem('netsuite_cache_invalidate');
                    localStorage.removeItem('netsuite_status');
                    console.log('    localStorage cleared');
                } catch (e) {
                    console.warn('    localStorage clear failed:', e.message);
                }
                
                updateLoading('Clearing in-memory caches...', 50);
                
                // STEP 2: Clear in-memory caches in custom functions runtime via __CLEARCACHE__ command
                // Use "ALL" as the items string to signal full cache clear
                console.log(' CLEAR CACHE: Sending __CLEARCACHE__ ALL command to custom functions...');
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    // Find an empty cell to use temporarily
                    const tempRange = sheet.getRange('ZZ9999');
                    
                    // Call BALANCE with __CLEARCACHE__ and "ALL" to clear everything
                    tempRange.formulas = [[`=XAVI.BALANCE("__CLEARCACHE__","ALL","")`]];
                    await context.sync();
                    
                    // Wait for the function to execute
                    await new Promise(r => setTimeout(r, 1000));
                    
                    tempRange.load('values');
                    await context.sync();
                    
                    const result = tempRange.values[0][0];
                    console.log('    __CLEARCACHE__ ALL result:', result);
                    
                    // Clean up temp cell
                    tempRange.clear();
                    await context.sync();
                });
                
                console.log(' All caches cleared successfully!');
                
                updateLoading('Cache cleared!', 100);
                await new Promise(resolve => setTimeout(resolve, 500));
                hideLoading();
                
                // Show success message
                statusEl.innerHTML = `<div style="background: #d1fae5; padding: 10px; border-radius: 6px;"><strong style="color: #059669;"> Cache cleared!</strong><br><span style="font-size: 11px;">Formulas will fetch fresh data from NetSuite</span></div>`;
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 5000);
                
            } catch (error) {
                console.error('Error clearing cache:', error);
                hideLoading();
                
                statusEl.innerHTML = `<div style="background: #fee2e2; padding: 10px; border-radius: 6px;"><strong style="color: #dc2626;"> Error:</strong> ${error.message}</div>`;
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 5000);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Clear Cache';
            }
        }

        async function refreshCurrentSheet() {
            const statusEl = document.getElementById('refreshStatus');
            const btn = event.target;
            
            try {
                btn.disabled = true;
                btn.textContent = 'Checking connection...';
                
                // Reset cancellation flag and show cancel button
                refreshCancelled = false;
                showCancelButton();
                
                // Clear any stale flags from previous runs
                localStorage.removeItem('netsuite_bulk_refresh');
                localStorage.removeItem('netsuite_show_toasts'); // Don't show toasts during Refresh Accounts
                
                // ============================================
                // STEP 0: Verify connection before starting
                // ============================================
                showLoading('Refresh Accounts', 'Verifying connection to NetSuite...', 2);
                
                const isConnected = await checkConnectionStatus(true);
                if (!isConnected) {
                    hideLoading();
                    hideCancelButton();
                    btn.disabled = false;
                    btn.innerHTML = '<span class="action-icon"></span>Refresh Accounts';
                    
                    showToast({ type: 'error', title: 'Connection Failed', 
                        message: 'Cannot reach the backend server. The Cloudflare tunnel may have expired. ' +
                        'Check the terminal for a new tunnel URL and update the Cloudflare Worker.', duration: 15000 });
                    
                    if (statusEl) {
                        statusEl.innerHTML = `<div style="background: #fee2e2; padding: 10px; border-radius: 6px; border-left: 4px solid #dc2626;">
                            <strong style="color: #dc2626;"> Connection Failed</strong><br>
                            <small style="color: #7f1d1d;">The tunnel may have expired. Check terminal for new URL.</small>
                        </div>`;
                    }
                    return;
                }
                
                btn.textContent = 'Analyzing...';
                showLoading('Refresh Accounts', 'Checking sheet type...', 5);
                
                // ============================================
                // CHECK FOR AUTO-GENERATED INCOME STATEMENT
                // If Structure Sync = TRUE, rebuild structure first
                // ============================================
                let shouldSyncStructure = false;
                let syncYear = null;
                let syncSubsidiary = null;
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    
                    // Check A3 for sync marker
                    const markerCell = sheet.getRange("A3");
                    markerCell.load("values");
                    
                    // Check B3 for sync flag
                    const syncCell = sheet.getRange("B3");
                    syncCell.load("values");
                    
                    // Get year and subsidiary if this is an auto-generated sheet
                    const yearCell = sheet.getRange("F2");
                    yearCell.load("values");
                    
                    const subCell = sheet.getRange("I2");
                    subCell.load("values");
                    
                    await context.sync();
                    
                    const markerValue = String(markerCell.values[0][0] || '').toLowerCase();
                    const syncValue = String(syncCell.values[0][0] || '').toUpperCase();
                    
                    // Check if this is an auto-generated sheet with sync enabled
                    if ((markerValue.includes('structure sync') || markerValue.includes('')) &&
                        (syncValue === 'TRUE' || syncValue === 'YES' || syncValue === '1')) {
                        shouldSyncStructure = true;
                        syncYear = parseInt(yearCell.values[0][0]) || new Date().getFullYear();
                        syncSubsidiary = subCell.values[0][0] || '';
                        console.log(` Auto-generated Income Statement detected. Year: ${syncYear}, Sync: enabled`);
                    }
                });
                
                // If this is an auto-generated sheet with sync enabled, rebuild structure
                if (shouldSyncStructure) {
                    showLoading('Refresh Accounts', `Syncing structure for ${syncYear}...`, 10);
                    console.log(` Rebuilding Income Statement structure for year ${syncYear}`);
                    
                    // Fetch accounts for the target year
                    const refreshResponse = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            year: syncYear,
                            subsidiary: '',
                            department: '',
                            location: '',
                            class: ''
                        })
                    });
                    
                    if (refreshResponse.ok) {
                        const refreshData = await refreshResponse.json();
                        const allBalances = refreshData.balances || {};
                        const accountTypes = refreshData.account_types || {};
                        const accountNames = refreshData.account_names || {};
                        
                        // Categorize accounts
                        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                           'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        
                        const categories = {
                            income: [], othIncome: [], cogs: [], expense: [], othExpense: []
                        };
                        
                        for (const acctNum in allBalances) {
                            const monthData = allBalances[acctNum];
                            const hasData = Object.values(monthData).some(val => val !== 0 && val !== null);
                            
                            if (hasData) {
                                const acctInfo = {
                                    number: acctNum,
                                    name: accountNames[acctNum] || `Account ${acctNum}`,
                                    type: accountTypes[acctNum] || 'Unknown'
                                };
                                
                                const acctType = (accountTypes[acctNum] || '').toLowerCase();
                                if (acctType === 'income') categories.income.push(acctInfo);
                                else if (acctType === 'othincome') categories.othIncome.push(acctInfo);
                                else if (acctType === 'cogs' || acctType === 'cost of goods sold') categories.cogs.push(acctInfo);
                                else if (acctType === 'expense') categories.expense.push(acctInfo);
                                else if (acctType === 'othexpense') categories.othExpense.push(acctInfo);
                            }
                        }
                        
                        // Sort categories
                        for (const cat in categories) {
                            categories[cat].sort((a, b) => a.number.localeCompare(b.number, undefined, {numeric: true}));
                        }
                        
                        const totalAccounts = categories.income.length + categories.othIncome.length + 
                                             categories.cogs.length + categories.expense.length + categories.othExpense.length;
                        
                        console.log(` Found ${totalAccounts} P&L accounts for ${syncYear}`);
                        showLoading('Refresh Accounts', `Rebuilding with ${totalAccounts} accounts...`, 20);
                        
                        // Rebuild the sheet
                        await Excel.run(async (context) => {
                            const sheet = context.workbook.worksheets.getActiveWorksheet();
                            
                            // Clear existing content
                            const usedRange = sheet.getUsedRange();
                            usedRange.clear();
                            await context.sync();
                            
                            // Remove gridlines
                            try {
                                sheet.showGridlines = false;
                                await context.sync();
                            } catch (e) {}
                            
                            // ===== ROW 1: TITLE =====
                            sheet.getRange("A1").formulas = [['="Income Statement For: "&F2']];
                            await context.sync();
                            try {
                                sheet.getRange("A1").format.font.bold = true;
                                sheet.getRange("A1").format.font.size = 18;
                                sheet.getRange("A1").format.font.color = "#09235C";
                                await context.sync();
                            } catch (e) {}
                            
                            // ===== ROW 2: PARAMETERS =====
                            sheet.getRange("E2").values = [["YEAR"]];
                            sheet.getRange("F2").values = [[syncYear]];
                            sheet.getRange("H2").values = [["Subsidiary"]];
                            sheet.getRange("I2").values = [[syncSubsidiary || 'Celigo Inc. (Consolidated)']];
                            await context.sync();
                            
                            try {
                                sheet.getRange("F2").format.fill.color = "#0AE2C1";
                                sheet.getRange("F2").format.font.bold = true;
                                sheet.getRange("I2").format.fill.color = "#0AE2C1";
                                sheet.getRange("I2").format.font.bold = true;
                                sheet.getRange("E2").format.font.bold = true;
                                sheet.getRange("H2").format.font.bold = true;
                                await context.sync();
                            } catch (e) {}
                            
                            // ===== ROW 3: SYNC FLAG =====
                            sheet.getRange("A3").values = [[" Structure Sync:"]];
                            sheet.getRange("B3").values = [["TRUE"]];
                            sheet.getRange("C3").values = [[" Change to FALSE if you customize this sheet"]];
                            await context.sync();
                            
                            try {
                                sheet.getRange("A3").format.font.bold = true;
                                sheet.getRange("B3").format.fill.color = "#0AE2C1";
                                sheet.getRange("B3").format.font.bold = true;
                                sheet.getRange("C3").format.font.italic = true;
                                sheet.getRange("C3").format.font.color = "#6B7280";
                                await context.sync();
                            } catch (e) {}
                            
                            // ===== ROW 5: HEADERS =====
                            sheet.getRange("A5").values = [["Account #"]];
                            sheet.getRange("B5").values = [["Account Name"]];
                            for (let m = 0; m < 12; m++) {
                                const col = String.fromCharCode(67 + m);
                                sheet.getRange(`${col}5`).formulas = [[`=DATE($F$2,${m + 1},1)`]];
                            }
                            sheet.getRange("O5").values = [["YTD Total"]];
                            await context.sync();
                            
                            try {
                                sheet.getRange("A5:O5").format.font.bold = true;
                                sheet.getRange("A5:O5").format.font.color = "#FFFFFF";
                                sheet.getRange("A5:O5").format.fill.color = "#09235C";
                                sheet.getRange("C5:N5").numberFormat = [['mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm', 'mmmm']];
                                await context.sync();
                            } catch (e) {}
                            
                            let currentRow = 6;
                            
                            // Helper functions
                            const writeSectionHeader = async (text, row) => {
                                sheet.getRange(`A${row}`).values = [[text]];
                                await context.sync();
                                try {
                                    sheet.getRange(`A${row}:O${row}`).format.font.bold = true;
                                    sheet.getRange(`A${row}:O${row}`).format.fill.color = "#E8EBF0";
                                    await context.sync();
                                } catch (e) {}
                            };
                            
                            const writeAccountRow = (acct, row) => {
                                sheet.getRange(`A${row}`).values = [[acct.number]];
                                sheet.getRange(`B${row}`).values = [[acct.name]];
                                for (let m = 0; m < 12; m++) {
                                    const col = String.fromCharCode(67 + m);
                                    sheet.getRange(`${col}${row}`).formulas = [[`=XAVI.BALANCE($A${row},TEXT(${col}$5,"mmm yyyy"),TEXT(${col}$5,"mmm yyyy"),$I$2)`]];
                                }
                                sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                            };
                            
                            const writeSubtotalRow = async (text, startRow, endRow, row) => {
                                sheet.getRange(`B${row}`).values = [[text]];
                                for (let m = 0; m < 12; m++) {
                                    const col = String.fromCharCode(67 + m);
                                    sheet.getRange(`${col}${row}`).formulas = [[`=SUM(${col}${startRow}:${col}${endRow})`]];
                                }
                                sheet.getRange(`O${row}`).formulas = [[`=SUM(C${row}:N${row})`]];
                                await context.sync();
                                try {
                                    sheet.getRange(`A${row}:O${row}`).format.font.bold = true;
                                    sheet.getRange(`A${row}:O${row}`).format.borders.getItem('EdgeTop').style = 'Continuous';
                                    await context.sync();
                                } catch (e) {}
                            };
                            
                            let revenueTotalRow, cogsTotalRow, grossProfitRow, expenseTotalRow, operatingIncomeRow;
                            let othIncomeTotalRow, othExpenseTotalRow, netIncomeRow;
                            
                            // REVENUE
                            if (categories.income.length > 0) {
                                await writeSectionHeader('REVENUE', currentRow++);
                                const startRow = currentRow;
                                for (const acct of categories.income) writeAccountRow(acct, currentRow++);
                                await context.sync();
                                await writeSubtotalRow('Total Revenue', startRow, currentRow - 1, currentRow);
                                revenueTotalRow = currentRow++;
                                currentRow++;
                            }
                            
                            // COGS
                            if (categories.cogs.length > 0) {
                                await writeSectionHeader('COST OF SALES', currentRow++);
                                const startRow = currentRow;
                                for (const acct of categories.cogs) writeAccountRow(acct, currentRow++);
                                await context.sync();
                                await writeSubtotalRow('Total Cost of Sales', startRow, currentRow - 1, currentRow);
                                cogsTotalRow = currentRow++;
                                currentRow++;
                            }
                            
                            // GROSS PROFIT
                            if (revenueTotalRow && cogsTotalRow) {
                                sheet.getRange(`B${currentRow}`).values = [['GROSS PROFIT']];
                                for (let m = 0; m < 12; m++) {
                                    const col = String.fromCharCode(67 + m);
                                    sheet.getRange(`${col}${currentRow}`).formulas = [[`=${col}${revenueTotalRow}-${col}${cogsTotalRow}`]];
                                }
                                sheet.getRange(`O${currentRow}`).formulas = [[`=SUM(C${currentRow}:N${currentRow})`]];
                                await context.sync();
                                try {
                                    sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                                    sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#D4E6F1";
                                    await context.sync();
                                } catch (e) {}
                                grossProfitRow = currentRow++;
                                currentRow++;
                            }
                            
                            // OPERATING EXPENSES
                            if (categories.expense.length > 0) {
                                await writeSectionHeader('OPERATING EXPENSES', currentRow++);
                                const startRow = currentRow;
                                for (const acct of categories.expense) writeAccountRow(acct, currentRow++);
                                await context.sync();
                                await writeSubtotalRow('Total Operating Expenses', startRow, currentRow - 1, currentRow);
                                expenseTotalRow = currentRow++;
                                currentRow++;
                            }
                            
                            // OPERATING INCOME
                            if (grossProfitRow && expenseTotalRow) {
                                sheet.getRange(`B${currentRow}`).values = [['OPERATING INCOME']];
                                for (let m = 0; m < 12; m++) {
                                    const col = String.fromCharCode(67 + m);
                                    sheet.getRange(`${col}${currentRow}`).formulas = [[`=${col}${grossProfitRow}-${col}${expenseTotalRow}`]];
                                }
                                sheet.getRange(`O${currentRow}`).formulas = [[`=SUM(C${currentRow}:N${currentRow})`]];
                                await context.sync();
                                try {
                                    sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                                    sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#D5F5E3";
                                    await context.sync();
                                } catch (e) {}
                                operatingIncomeRow = currentRow++;
                                currentRow++;
                            }
                            
                            // OTHER INCOME
                            if (categories.othIncome.length > 0) {
                                await writeSectionHeader('OTHER INCOME', currentRow++);
                                const startRow = currentRow;
                                for (const acct of categories.othIncome) writeAccountRow(acct, currentRow++);
                                await context.sync();
                                await writeSubtotalRow('Total Other Income', startRow, currentRow - 1, currentRow);
                                othIncomeTotalRow = currentRow++;
                                currentRow++;
                            }
                            
                            // OTHER EXPENSE
                            if (categories.othExpense.length > 0) {
                                await writeSectionHeader('OTHER EXPENSE', currentRow++);
                                const startRow = currentRow;
                                for (const acct of categories.othExpense) writeAccountRow(acct, currentRow++);
                                await context.sync();
                                await writeSubtotalRow('Total Other Expense', startRow, currentRow - 1, currentRow);
                                othExpenseTotalRow = currentRow++;
                                currentRow++;
                            }
                            
                            // NET INCOME
                            sheet.getRange(`B${currentRow}`).values = [['NET INCOME']];
                            for (let m = 0; m < 12; m++) {
                                const col = String.fromCharCode(67 + m);
                                let formula = '=';
                                if (operatingIncomeRow) formula += `${col}${operatingIncomeRow}`;
                                else if (grossProfitRow) formula += `${col}${grossProfitRow}`;
                                else if (revenueTotalRow) formula += `${col}${revenueTotalRow}`;
                                else formula += '0';
                                if (othIncomeTotalRow) formula += `+${col}${othIncomeTotalRow}`;
                                if (othExpenseTotalRow) formula += `-${col}${othExpenseTotalRow}`;
                                sheet.getRange(`${col}${currentRow}`).formulas = [[formula]];
                            }
                            sheet.getRange(`O${currentRow}`).formulas = [[`=SUM(C${currentRow}:N${currentRow})`]];
                            await context.sync();
                            
                            try {
                                sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.bold = true;
                                sheet.getRange(`A${currentRow}:O${currentRow}`).format.fill.color = "#09235C";
                                sheet.getRange(`A${currentRow}:O${currentRow}`).format.font.color = "#FFFFFF";
                                await context.sync();
                            } catch (e) {}
                            netIncomeRow = currentRow;
                            
                            // Format numbers
                            try {
                                const rows = netIncomeRow - 5;
                                const formatArray = Array(rows).fill(null).map(() => Array(13).fill('"$"#,##0'));
                                sheet.getRange(`C6:O${netIncomeRow}`).numberFormat = formatArray;
                                await context.sync();
                            } catch (e) {}
                            
                            // Freeze header rows
                            try {
                                sheet.freezePanes.freezeRows(5);
                                await context.sync();
                            } catch (e) {}
                        });
                        
                        console.log(` Income Statement structure synced for ${syncYear}`);
                    }
                    
                    // After sync, the formulas are already set up - we're done!
                    hideLoading();
                    hideCancelButton();
                    btn.disabled = false;
                    btn.innerHTML = '<span class="action-icon"></span>Refresh Accounts';
                    
                    if (statusEl) {
                        statusEl.innerHTML = `<div style="background: #d1fae5; padding: 10px; border-radius: 6px; border-left: 4px solid #10b981;">
                            <strong style="color: #065f46;"> Structure Synced for ${syncYear}</strong><br>
                            <small style="color: #047857;">Income Statement rebuilt with all accounts for ${syncYear}. Formulas will resolve shortly.</small>
                        </div>`;
                    }
                    return; // Exit early - structure sync handles everything
                }
                
                // Continue with normal refresh for non-auto-generated sheets...
                showLoading('Refresh Accounts', 'Scanning formulas on sheet...', 5);
                
                // NOTE: We do NOT set netsuite_show_toasts during Refresh Accounts
                // All status updates go to the task pane instead of toast popups
                // This prevents toasts from appearing during bulk operations
                console.log(' Refresh Accounts mode - toasts will NOT appear (status in task pane only)');
                
                const start = Date.now();
                let formulasFound = [];
                let detectedYears = new Set();
                let detectedPeriods = new Set();  // Specific periods like "Dec 2024", "Jan 2025"
                let detectedAccounts = new Set();
                let cellsToUpdate = [];  // BALANCE formulas
                let specialFormulas = []; // RETAINEDEARNINGS, NETINCOME, CTA formulas
                
                // ============================================
                // STEP 1: Scan sheet to detect years & accounts
                // ============================================
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load("formulas, values, rowCount, columnCount, address");
                    await context.sync();
                    
                    const formulas = usedRange.formulas;
                    const values = usedRange.values;
                    const rowCount = usedRange.rowCount;
                    const colCount = usedRange.columnCount;
                    
                    console.log(` Scanning ${rowCount}  ${colCount} cells...`);
                    
                    // Find all XAVI formulas (BALANCE and special formulas)
                    for (let row = 0; row < rowCount; row++) {
                        for (let col = 0; col < colCount; col++) {
                            const formula = formulas[row][col];
                            if (formula && typeof formula === 'string') {
                                const upperFormula = formula.toUpperCase();
                                
                                // BALANCE formulas - refresh first
                                if (upperFormula.includes('XAVI.BALANCE')) {
                                cellsToUpdate.push({ row, col, formula });
                                
                                // Try to extract account from formula
                                const accountMatch = formula.match(/XAVI\.BALANCE\s*\(\s*["']?(\d+)["']?/i);
                                if (accountMatch) {
                                    detectedAccounts.add(accountMatch[1]);
                                    }
                                }
                                
                                // Special formulas - refresh AFTER BALANCE data is loaded
                                if (upperFormula.includes('XAVI.RETAINEDEARNINGS') ||
                                    upperFormula.includes('XAVI.NETINCOME') ||
                                    upperFormula.includes('XAVI.CTA')) {
                                    const formulaType = upperFormula.includes('RETAINEDEARNINGS') ? 'RETAINEDEARNINGS' :
                                                       upperFormula.includes('NETINCOME') ? 'NETINCOME' : 'CTA';
                                    specialFormulas.push({ row, col, formula, type: formulaType });
                                }
                            }
                        }
                    }
                    
                    // Also scan for date values to detect SPECIFIC PERIODS (not just years)
                    // Support multiple formats: "Jan 2025", "12/1/24", Excel serial dates
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const dateSlashFormat = /^\d{1,2}\/\d{1,2}\/\d{2,4}$/;  // "12/1/24" or "12/1/2024"
                    
                    // Helper to convert date to "Mon YYYY" format
                    function toPeriodFormat(date) {
                        if (!date || isNaN(date.getTime())) return null;
                        return `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
                    }
                    
                    for (let row = 0; row < Math.min(rowCount, 20); row++) {
                        for (let col = 0; col < Math.min(colCount, 50); col++) {
                            const cellValue = values[row][col];
                            const val = String(cellValue || '').trim();
                            
                            // Check for "Jan 2025" format - already in correct format!
                            const monYearMatch = val.match(/^([A-Za-z]{3})\s+(20\d{2})$/);
                            if (monYearMatch) {
                                const monthIdx = monthNames.findIndex(m => m.toLowerCase() === monYearMatch[1].toLowerCase());
                                if (monthIdx >= 0) {
                                    const period = `${monthNames[monthIdx]} ${monYearMatch[2]}`;
                                    detectedPeriods.add(period);
                                    detectedYears.add(parseInt(monYearMatch[2]));
                                    continue;
                                }
                            }
                            
                            // Check for "12/1/24" or "1/1/25" or "12/1/2024" format
                            if (dateSlashFormat.test(val)) {
                                const parts = val.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
                                if (parts) {
                                    let year = parseInt(parts[3]);
                                    // Convert 2-digit year: 24 -> 2024, 25 -> 2025
                                    if (year < 100) year += 2000;
                                    const month = parseInt(parts[1]) - 1; // 0-indexed
                                    if (month >= 0 && month < 12) {
                                        const period = `${monthNames[month]} ${year}`;
                                        detectedPeriods.add(period);
                                        detectedYears.add(year);
                                    }
                                }
                                continue;
                            }
                            
                            // Check for Excel serial date number (e.g., 45627)
                            if (typeof cellValue === 'number' && cellValue > 30000 && cellValue < 60000) {
                                // Convert Excel serial to JS date
                                const excelEpoch = new Date(1899, 11, 30);
                                const jsDate = new Date(excelEpoch.getTime() + cellValue * 86400000);
                                const period = toPeriodFormat(jsDate);
                                if (period) {
                                    detectedPeriods.add(period);
                                    detectedYears.add(jsDate.getFullYear());
                                }
                            }
                        }
                    }
                    
                    console.log(` Detected SPECIFIC periods: ${[...detectedPeriods].join(', ')}`);
                    console.log(` Detected years: ${[...detectedYears].sort().join(', ')}`);
                });
                
                console.log(` Found ${cellsToUpdate.length} XAVI.BALANCE formulas`);
                console.log(` Found ${specialFormulas.length} special formulas (RETAINEDEARNINGS/NETINCOME/CTA)`);
                console.log(` Detected accounts: ${detectedAccounts.size}`);
                console.log(` Detected periods: ${[...detectedPeriods].join(', ')} (${detectedPeriods.size} total)`);
                console.log(` Detected years: ${[...detectedYears].join(', ')}`);
                
                if (cellsToUpdate.length === 0 && specialFormulas.length === 0) {
                    hideLoading();
                    statusEl.innerHTML = `<div style="background: #fef3c7; padding: 10px; border-radius: 6px;"><strong style="color: #92400e;">No XAVI formulas found</strong></div>`;
                    setTimeout(() => { statusEl.textContent = ''; }, 5000);
                    return;
                }
                
                // Default to current year if none detected
                if (detectedYears.size === 0) {
                    detectedYears.add(new Date().getFullYear());
                }
                
                const yearsArray = [...detectedYears].sort();
                
                // ============================================
                // STEP 2: Get account types to classify P&L vs BS
                // ============================================
                updateLoading('Classifying accounts...', 10, `${detectedAccounts.size} accounts found`);
                
                let plAccounts = [];
                let bsAccounts = [];
                
                if (detectedAccounts.size > 0) {
                    try {
                        const typeResponse = await fetch(`${SERVER_URL}/batch/account_types`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ accounts: [...detectedAccounts] })
                        });
                        
                        if (typeResponse.ok) {
                            const typeData = await typeResponse.json();
                            // All Balance Sheet account types in NetSuite
                            // Assets: Bank, AcctRec, OthCurrAsset, FixedAsset, OthAsset, DeferExpense (Prepaid), UnbilledRec
                            // Liabilities: AcctPay, CredCard (NOT CreditCard!), OthCurrLiab, LongTermLiab, DeferRevenue
                            // Equity: Equity, RetainedEarnings
                            const bsTypes = ['Bank', 'AcctRec', 'OthCurrAsset', 'FixedAsset', 'OthAsset', 'DeferExpense',
                                           'AcctPay', 'CredCard', 'OthCurrLiab', 'LongTermLiab', 'DeferRevenue',
                                           'Equity', 'RetainedEarnings', 'UnbilledRec'];
                            
                            // Log which types we received for debugging
                            console.log(' Account types from API:', JSON.stringify(typeData.types));
                            
                            for (const [acct, type] of Object.entries(typeData.types || {})) {
                                const isBsType = bsTypes.includes(type);
                                console.log(`   Account ${acct}: type="${type}"  ${isBsType ? 'BS' : 'P&L'}`);
                                if (isBsType) {
                                    bsAccounts.push(acct);
                                } else {
                                    plAccounts.push(acct);
                                }
                            }
                            console.log(` P&L accounts: ${plAccounts.length}, BS accounts: ${bsAccounts.length}`);
                        }
                    } catch (e) {
                        // If type API fails, fetch BOTH P&L and BS to be safe
                        // This is slower but ensures no accounts are missed
                        console.error(' Type API failed! Will fetch BOTH P&L and BS:', e);
                        plAccounts = [...detectedAccounts];
                        bsAccounts = [...detectedAccounts];
                        showToast({ type: 'warning', title: 'Account Classification Failed', 
                            message: 'Could not classify accounts. Fetching both P&L and BS data to be safe (slower).', duration: 8000 });
                    }
                }
                
                // Clear cache before fetching - MUST use __CLEARCACHE__ formula
                // because functions.js runs in a separate iframe context
                localStorage.removeItem('netsuite_balance_cache');
                localStorage.removeItem('netsuite_balance_cache_timestamp');
                
                console.log(' Clearing caches via __CLEARCACHE__ command...');
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const tempRange = sheet.getRange('ZZ9999');
                    tempRange.formulas = [[`=XAVI.BALANCE("__CLEARCACHE__","ALL","")`]];
                    await context.sync();
                    await new Promise(r => setTimeout(r, 500));
                    tempRange.clear();
                    await context.sync();
                });
                console.log(' Cache cleared via __CLEARCACHE__');
                
                let totalAccountsLoaded = 0;
                let allBalances = {};
                
                // ============================================
                // STEP 3: Fetch P&L accounts (fast ~30s/year)
                // ONLY fetch P&L if there are actually P&L accounts detected
                // If detectedAccounts is empty AND there are BALANCE formulas, 
                // we still need to classify them - skip P&L in that case
                // ============================================
                console.log(` P&L decision: plAccounts=${plAccounts.length}, bsAccounts=${bsAccounts.length}, detectedAccounts=${detectedAccounts.size}`);
                
                // ONLY fetch P&L if we actually have P&L accounts identified
                if (plAccounts.length > 0) {
                    console.log(` Fetching P&L data for ${plAccounts.length} accounts: ${plAccounts.join(', ')}`);
                    updateLoading('Fetching P&L accounts...', 15, `${plAccounts.length} P&L accounts, Years: ${yearsArray.join(', ')}`);
                    
                    for (let i = 0; i < yearsArray.length; i++) {
                        // Check for cancellation
                        if (refreshCancelled) {
                            console.log(` Refresh cancelled - stopping P&L fetch at year ${i + 1}/${yearsArray.length}`);
                            break;
                        }
                        
                        const year = yearsArray[i];
                        const progress = 15 + (i / yearsArray.length) * 35;
                        updateLoading(`Fetching P&L data for ${year}...`, progress, 
                            `Year ${i + 1} of ${yearsArray.length}  ${plAccounts.length} P&L accounts`);
                        
                        try {
                const response = await fetch(`${SERVER_URL}/batch/full_year_refresh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        year: year,
                                    skip_bs: true, // P&L only
                        subsidiary: '',
                        department: '',
                        location: '',
                        class: ''
                    })
                });
                
                            if (response.ok) {
                                const data = await response.json();
                                Object.assign(allBalances, data.balances || {});
                                totalAccountsLoaded += Object.keys(data.balances || {}).length;
                                console.log(` Year ${year}: ${Object.keys(data.balances || {}).length} P&L accounts`);
                            } else if (response.status === 502 || response.status === 524 || response.status === 522) {
                                // Tunnel/proxy error - this is critical
                                console.error(` P&L fetch FAILED: Tunnel error ${response.status}`);
                                showToast({ type: 'error', title: 'Connection Lost', 
                                    message: `Tunnel error (${response.status}) while fetching P&L data. The tunnel may have expired.`, duration: 10000 });
                                // Update connection status
                                await checkConnectionStatus(true);
                            } else {
                                console.error(` P&L fetch error: ${response.status}`);
                                showToast({ type: 'warning', title: 'P&L Fetch Warning', 
                                    message: `Error ${response.status} loading P&L for ${year}. Some data may be missing.`, duration: 6000 });
                            }
                        } catch (e) {
                            console.error(`Error fetching year ${year}:`, e);
                            showToast({ type: 'error', title: 'P&L Fetch Error', 
                                message: `Failed to load P&L for ${year}: ${e.message}. Check connection.`, duration: 8000 });
                            // Update connection status
                            await checkConnectionStatus(true);
                        }
                    }
                } else {
                    console.log(' SKIPPING P&L fetch - no P&L accounts detected on sheet');
                    updateLoading('No P&L accounts to fetch', 50, 'All detected accounts are Balance Sheet type');
                }
                
                // ============================================
                // STEP 4: Fetch Balance Sheet accounts (OPTIMIZED!)
                // Uses batch_bs_periods endpoint - ONE query for ALL periods
                // Instead of 12 queries (~14 min), runs 1 query (~36 sec)
                // ============================================
                console.log(` BS decision: bsAccounts=${bsAccounts.length}, detectedAccounts=${detectedAccounts.size}`);
                
                // ONLY fetch BS if we have BS accounts, OR if we have no accounts at all (fallback for all BALANCE formulas)
                if (bsAccounts.length > 0 || (detectedAccounts.size === 0 && cellsToUpdate.length > 0)) {
                    const bsCount = bsAccounts.length || 'All detected';
                    console.log(` ${bsCount} Balance Sheet accounts detected: ${bsAccounts.join(', ') || '(all accounts)'}`);
                    console.log(` Fetching BS for ${bsCount} accounts`);
                    updateLoading('Fetching Balance Sheet accounts...', 50, 
                        `Unlike P&L accounts, Balance Sheet accounts must be summed from the beginning of time (inception-to-date). Using OPTIMIZED single-query approach.`);
                    
                    // Use ONLY the specific periods detected on the sheet (not all 12 months per year!)
                    const allPeriods = [...detectedPeriods];
                    
                    // If no specific periods detected, fall back to all months for detected years
                    if (allPeriods.length === 0 && yearsArray.length > 0) {
                        const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                       'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        for (const year of yearsArray) {
                            for (const month of months) {
                                allPeriods.push(`${month} ${year}`);
                            }
                        }
                        console.log(` BS: No specific periods detected, falling back to all ${allPeriods.length} periods`);
                    } else {
                        console.log(` BS: Fetching ONLY ${allPeriods.length} specific periods (optimized!)`);
                    }
                    updateLoading(`Fetching BS data (${allPeriods.length} periods)...`, 55, 
                        `Running single query for ${allPeriods.length} BS periods. ~${Math.max(10, allPeriods.length * 2)} seconds.`);
                    
                    try {
                        // Use the EFFICIENT batch_bs_periods endpoint
                        const response = await fetch(`${SERVER_URL}/batch/bs_periods`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                periods: allPeriods,
                                    subsidiary: '',
                                    department: '',
                                    location: '',
                                    class: ''
                                })
                            });
                            
                            if (response.ok) {
                                const data = await response.json();
                                // Merge BS balances into allBalances
                                for (const [acct, periods] of Object.entries(data.balances || {})) {
                                    if (!allBalances[acct]) allBalances[acct] = {};
                                    Object.assign(allBalances[acct], periods);
                                }
                                totalAccountsLoaded += Object.keys(data.balances || {}).length;
                            console.log(` BS: ${Object.keys(data.balances || {}).length} accounts loaded in ${data.query_time?.toFixed(1) || '?'}s`);
                            updateLoading('BS data loaded!', 85, 
                                `${Object.keys(data.balances || {}).length} BS accounts in ${data.query_time?.toFixed(1) || '?'}s`);
                        } else if (response.status === 524 || response.status === 522 || response.status === 504) {
                            // Tunnel timeout - show warning
                            console.error(` BS fetch TIMEOUT (${response.status})`);
                            updateLoading(`BS fetch timed out`, 85, 
                                `Tunnel timeout (${response.status}). BS formulas may show stale data.`);
                            showToast({ type: 'warning', title: 'Balance Sheet Timeout', 
                                message: `BS query timed out (${response.status}). Use "Refresh Selected" on individual cells.`, duration: 10000 });
                        } else {
                            console.error(` BS fetch error: ${response.status}`);
                            showToast({ type: 'error', title: 'BS Fetch Error', message: `Error ${response.status} loading Balance Sheet data.`, duration: 8000 });
                            }
                    } catch (e) {
                        console.error(`Error fetching BS data:`, e);
                        showToast({ type: 'error', title: 'BS Fetch Error', message: `Error loading Balance Sheet: ${e.message}. Check connection.`, duration: 8000 });
                        // Update connection status
                        await checkConnectionStatus(true);
                    }
                }
                
                // ============================================
                // STEP 5: Save to localStorage cache
                // ============================================
                updateLoading('Saving to cache...', 88, `${totalAccountsLoaded} accounts loaded`);
                
                const accountsLoaded = Object.keys(allBalances).length;
                let periodsLoaded = 0;
                for (const acct in allBalances) {
                    periodsLoaded += Object.keys(allBalances[acct]).length;
                }
                
                console.log(` Preparing to save: ${accountsLoaded} accounts, ${periodsLoaded} period values`);
                
                // Log the data status (not an error if there are simply no accounts on the sheet)
                if (accountsLoaded === 0) {
                    // Only show error if we had accounts to fetch but got nothing back
                    // This is NOT an error if the sheet simply has no BALANCE formulas
                    if (cellsToUpdate.length > 0) {
                        console.warn(' No balance data loaded but BALANCE formulas exist on sheet');
                        // Don't show error toast - formulas will individually resolve via cache misses
                    } else {
                        console.log(' No BALANCE formulas detected on sheet - nothing to cache');
                    }
                } else {
                    console.log(` Sample data: ${JSON.stringify(Object.entries(allBalances).slice(0,2))}`);
                }
                
                try {
                    const cacheJson = JSON.stringify(allBalances);
                    const cacheTimestamp = Date.now().toString();
                    
                    localStorage.setItem('netsuite_balance_cache', cacheJson);
                    localStorage.setItem('netsuite_balance_cache_timestamp', cacheTimestamp);
                    
                    // Verify the save was successful - but don't show error for empty cache
                    const verifyData = localStorage.getItem('netsuite_balance_cache');
                    const verifyTimestamp = localStorage.getItem('netsuite_balance_cache_timestamp');
                    
                    if (!verifyData) {
                        // Only show error if localStorage actually failed (not just empty data)
                        console.error(' localStorage save FAILED - could not write to storage');
                        showToast({ type: 'error', title: 'Cache Save Failed', 
                            message: 'Failed to save balance data to cache. Check browser storage settings.', duration: 10000 });
                    } else {
                        console.log(` localStorage save VERIFIED: ${verifyData.length} chars, timestamp=${verifyTimestamp}`);
                    }
                    
                    // Small delay to ensure localStorage is fully synced across contexts
                    await new Promise(r => setTimeout(r, 200));
                    
                } catch (e) {
                    console.error('localStorage save error:', e);
                    showToast({ type: 'error', title: 'Cache Error', 
                        message: `Failed to save data: ${e.message}`, duration: 10000 });
                }
                
                // Also populate the in-memory cache if Shared Runtime is available
                if (typeof window.setFullYearCache === 'function') {
                    try { 
                        window.setFullYearCache(allBalances); 
                        console.log(' setFullYearCache called successfully');
                    } catch (e) {
                        console.warn('setFullYearCache failed:', e.message);
                    }
                } else {
                    console.log(' setFullYearCache not available (Shared Runtime may not be active)');
                }
                
                // ============================================
                // STEP 6: Re-apply formulas to force evaluation
                // ============================================
                updateLoading('Re-evaluating formulas...', 90, `${cellsToUpdate.length} formulas`);
                
                let formulasRefreshed = 0;
                const BATCH_SIZE = 100;
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load("address");
                    await context.sync();
                    
                    const totalBatches = Math.ceil(cellsToUpdate.length / BATCH_SIZE);
                    
                    for (let batchNum = 0; batchNum < totalBatches; batchNum++) {
                        const batchStart = batchNum * BATCH_SIZE;
                        const batchEnd = Math.min(batchStart + BATCH_SIZE, cellsToUpdate.length);
                        const batch = cellsToUpdate.slice(batchStart, batchEnd);
                        
                        const progress = 90 + Math.round((batchNum / totalBatches) * 8);
                        updateLoading(`Refreshing formulas...`, progress, 
                            `Batch ${batchNum + 1}/${totalBatches}`);
                        
                        for (const { row, col, formula } of batch) {
                            const cell = usedRange.getCell(row, col);
                            cell.formulas = [[formula]];
                            formulasRefreshed++;
                        }
                        
                        await context.sync();
                        
                        if (batchNum < totalBatches - 1) {
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                    }
                    
                    updateLoading('Recalculating BALANCE formulas...', 92);
                    usedRange.calculate();
                    await context.sync();
                });
                
                // ============================================
                // CRITICAL: Wait for BALANCE formulas to actually resolve
                // context.sync() only sends the command - formulas may still be #BUSY#
                // We need to poll and wait for them to finish before moving on
                // ============================================
                updateLoading('Waiting for BALANCE formulas to resolve...', 93);
                console.log(' Waiting for BALANCE formulas to resolve (up to 2 minutes)...');
                
                const balanceWaitStart = Date.now();
                const maxBalanceWait = 120000; // 2 minutes max wait for BALANCE formulas
                let balanceResolved = false;
                
                while (Date.now() - balanceWaitStart < maxBalanceWait) {
                    let busyCount = 0;
                    let resolvedCount = 0;
                    
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const usedRange = sheet.getUsedRange();
                        usedRange.load('values');
                        await context.sync();
                        
                        const values = usedRange.values;
                        for (let row = 0; row < values.length; row++) {
                            for (let col = 0; col < values[row].length; col++) {
                                const val = String(values[row][col] || '');
                                if (val.includes('BUSY') || val === '#BUSY!' || val === '#BUSY#') {
                                    busyCount++;
                                }
                            }
                        }
                        resolvedCount = cellsToUpdate.length - busyCount;
                    });
                    
                    const elapsed = ((Date.now() - balanceWaitStart) / 1000).toFixed(1);
                    
                    if (busyCount === 0) {
                        console.log(` All BALANCE formulas resolved in ${elapsed}s`);
                        balanceResolved = true;
                        break;
                    }
                    
                    console.log(`    Still waiting: ${busyCount} formulas still calculating (${elapsed}s)...`);
                    updateLoading('Waiting for BALANCE formulas...', 93, 
                        `${busyCount} formulas still calculating...`);
                    
                    // Wait 2 seconds before checking again
                    await new Promise(r => setTimeout(r, 2000));
                }
                
                if (!balanceResolved) {
                    console.warn(` BALANCE formulas did not fully resolve within ${maxBalanceWait/1000}s - proceeding anyway`);
                }
                
                // ============================================
                // BALANCE formulas complete - notify user
                // NOTE: Special formulas (NI/RE/CTA) are NOT refreshed here
                // Use "Recalculate RE/NI/CTA" button for those
                // ============================================
                const balanceElapsed = ((Date.now() - start) / 1000).toFixed(1);
                console.log(` BALANCE formulas complete in ${balanceElapsed}s`);
                
                // Clear bulk refresh flag
                localStorage.removeItem('netsuite_bulk_refresh');
                localStorage.removeItem('netsuite_show_toasts');
                
                const elapsed = ((Date.now() - start) / 1000).toFixed(1);
                
                if (refreshCancelled) {
                    // Cancelled - already handled
                } else {
                updateLoading('Complete!', 100, `${formulasRefreshed} formulas refreshed`);
                await new Promise(resolve => setTimeout(resolve, 800));
                }
                
                hideLoading();
                hideCancelButton();
                
                // Check if data was actually loaded
                const dataLoaded = Object.keys(allBalances).length > 0;
                
                // Build summary message
                let summaryParts = [];
                if (plAccounts.length > 0 || bsAccounts.length === 0) {
                    summaryParts.push(`P&L: ${yearsArray.length} year(s)`);
                }
                if (bsAccounts.length > 0) {
                    summaryParts.push(`Balance Sheet: ${bsAccounts.length} accounts`);
                }
                
                // Check if there are special formulas on the sheet that need manual refresh
                const hasSpecialFormulas = specialFormulas.length > 0;
                
                if (!dataLoaded) {
                    // WARNING: No data was loaded - likely connection issue
                    statusEl.innerHTML = `
                        <div style="background: #fef3c7; padding: 12px; border-radius: 8px; margin-top: 10px; border-left: 4px solid #f59e0b;">
                            <strong style="color: #b45309; font-size: 14px;"> Refresh Complete - No Data Loaded!</strong><br>
                            <span style="font-size: 12px; color: #92400e;">
                                Formulas were refreshed but no account data was retrieved.<br>
                                This usually means the tunnel is down or expired.<br>
                                Check the connection status and try again.
                            </span>
                        </div>
                    `;
                    showToast({ type: 'warning', title: 'No Data Retrieved', 
                        message: 'Formulas refreshed but no account data was loaded. The tunnel may have issues.', duration: 10000 });
                } else {
                    let specialNote = '';
                    if (hasSpecialFormulas) {
                        specialNote = `<br><span style="color: #92400e; font-style: italic;"> ${specialFormulas.length} RE/NI/CTA formula(s) detected. Use "Recalculate RE/NI/CTA" button to refresh them.</span>`;
                }
                
                statusEl.innerHTML = `
                    <div style="background: #d1fae5; padding: 12px; border-radius: 8px; margin-top: 10px; animation: fadeIn 0.3s;">
                            <strong style="color: #059669; font-size: 14px;"> Account Balances Refreshed!</strong><br>
                        <span style="font-size: 12px; color: #047857;">
                            ${summaryParts.join('  ')}<br>
                                ${totalAccountsLoaded} accounts loaded  ${formulasRefreshed} BALANCE formulas refreshed in ${elapsed}s
                                ${specialNote}
                        </span>
                    </div>
                `;
                }
                
                setTimeout(() => { statusEl.textContent = ''; }, 15000);
                
            } catch (error) {
                console.error('Error refreshing sheet:', error);
                hideLoading();
                hideCancelButton();
                hideToast(); // Clear any lingering toast
                
                // Clear bulk refresh flag on error
                localStorage.removeItem('netsuite_bulk_refresh');
                localStorage.removeItem('netsuite_show_toasts');
                
                statusEl.innerHTML = `
                    <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #dc2626;"> Error</strong><br>
                        <span style="font-size: 12px; color: #991b1b;">${error.message}</span>
                    </div>
                `;
                
                setTimeout(() => { statusEl.textContent = ''; }, 8000);
            } finally {
                // Always clean up
                localStorage.removeItem('netsuite_bulk_refresh');
                hideToast();
                btn.disabled = false;
                btn.innerHTML = '<span class="action-icon"></span><span class="action-text">Refresh Accounts</span>';
            }
        }

        // ============================================
        // RECALCULATE SPECIAL FORMULAS (RE, NI, CTA)
        // Separate from Refresh Accounts because these require
        // scanning entire transaction history and take up to 5 minutes
        // Uses floating status so user can continue working
        // ============================================
        async function recalculateSpecialFormulas() {
            const statusEl = document.getElementById('refreshStatus');
            const btn = event.target;
            
            // Light orange color for highlighting pending cells
            const PENDING_COLOR = '#FEF3C7'; // Light amber/orange
            
            try {
                btn.disabled = true;
                const start = Date.now();
                
                // Check connection first (brief full overlay just for connection check)
                showLoading('Recalculate Retained Earnings', 'Verifying connection...', 5);
                const isConnected = await checkConnectionStatus(true);
                if (!isConnected) {
                    hideLoading();
                    btn.disabled = false;
                    statusEl.innerHTML = `
                        <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px;">
                            <strong style="color: #dc2626;"> Not Connected</strong><br>
                            <span style="font-size: 12px; color: #991b1b;">Cannot reach NetSuite server. Please check your connection.</span>
                        </div>
                    `;
                    return;
                }
                
                updateLoading('Scanning for formulas...', 10);
                
                // Scan sheet for special formulas AND resolve cell references to actual dates
                let specialFormulas = [];
                let detectedPeriods = new Set();
                
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    usedRange.load("values, formulas, rowCount, columnCount, address");
                    await context.sync();
                    
                    const formulas = usedRange.formulas;
                    const values = usedRange.values;
                    
                    // Helper to resolve cell reference to value
                    const resolveCellRef = async (cellRef) => {
                        try {
                            const refRange = sheet.getRange(cellRef);
                            refRange.load('values');
                            await context.sync();
                            return refRange.values[0][0];
                        } catch (e) {
                            return cellRef; // Return as-is if can't resolve
                        }
                    };
                    
                    for (let row = 0; row < usedRange.rowCount; row++) {
                        for (let col = 0; col < usedRange.columnCount; col++) {
                            const formula = formulas[row][col];
                            if (typeof formula === 'string' && formula.startsWith('=')) {
                                const upperFormula = formula.toUpperCase();
                                
                                if (upperFormula.includes('XAVI.RETAINEDEARNINGS') ||
                                    upperFormula.includes('XAVI.NETINCOME') ||
                                    upperFormula.includes('XAVI.CTA')) {
                                    const formulaType = upperFormula.includes('RETAINEDEARNINGS') ? 'RETAINEDEARNINGS' :
                                                       upperFormula.includes('NETINCOME') ? 'NETINCOME' : 'CTA';
                                    
                                    // Extract period - could be a string literal or a cell reference
                                    const periodMatch = formula.match(/\(([^,)]+)/);
                                    let rawPeriod = '';
                                    let resolvedPeriod = '';
                                    
                                    if (periodMatch) {
                                        rawPeriod = periodMatch[1].replace(/["']/g, '').trim();
                                        
                                        // Check if it's a cell reference (like L$3, $L3, L3, etc.)
                                        if (rawPeriod.match(/^\$?[A-Z]+\$?\d+$/i)) {
                                            // It's a cell reference - resolve it
                                            const refValue = await resolveCellRef(rawPeriod);
                                            if (refValue) {
                                                // Could be a date serial number or a string
                                                if (typeof refValue === 'number') {
                                                    // Excel date serial - convert to readable date
                                                    const date = new Date((refValue - 25569) * 86400 * 1000);
                                                    const months = ['January', 'February', 'March', 'April', 'May', 'June',
                                                                   'July', 'August', 'September', 'October', 'November', 'December'];
                                                    resolvedPeriod = `${months[date.getMonth()]} ${date.getFullYear()}`;
                                                } else {
                                                    resolvedPeriod = String(refValue);
                                                }
                                            }
                                        } else if (rawPeriod.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}$/i)) {
                                            // It's already a period string
                                            resolvedPeriod = rawPeriod;
                                            detectedPeriods.add(rawPeriod);
                                        }
                                    }
                                    
                                    specialFormulas.push({ 
                                        row, col, formula, type: formulaType, 
                                        rawPeriod, resolvedPeriod: resolvedPeriod || rawPeriod 
                                    });
                                }
                            }
                        }
                    }
                });
                
                if (specialFormulas.length === 0) {
                    hideLoading();
                    statusEl.innerHTML = `
                        <div style="background: #fef3c7; padding: 12px; border-radius: 8px; margin-top: 10px;">
                            <strong style="color: #92400e;">No Formulas Found</strong><br>
                            <span style="font-size: 12px; color: #a16207;">This sheet doesn't contain any XAVI.RETAINEDEARNINGS, XAVI.NETINCOME, or XAVI.CTA formulas.</span>
                        </div>
                    `;
                    btn.disabled = false;
                    setTimeout(() => { statusEl.textContent = ''; }, 8000);
                    return;
                }
                
                console.log(` Found ${specialFormulas.length} special formulas to recalculate`);
                
                // Sort by type: NETINCOME first (fastest), then RETAINEDEARNINGS, then CTA (slowest)
                const typeOrder = { 'NETINCOME': 1, 'RETAINEDEARNINGS': 2, 'CTA': 3 };
                specialFormulas.sort((a, b) => (typeOrder[a.type] || 99) - (typeOrder[b.type] || 99));
                
                // Highlight ALL cells that will be recalculated with light orange
                console.log(' Highlighting cells to be recalculated...');
                await Excel.run(async (context) => {
                    const sheet = context.workbook.worksheets.getActiveWorksheet();
                    const usedRange = sheet.getUsedRange();
                    
                    for (const { row, col } of specialFormulas) {
                        const cell = usedRange.getCell(row, col);
                        cell.format.fill.color = PENDING_COLOR;
                    }
                    await context.sync();
                });
                
                // Hide full overlay - switch to floating status
                hideLoading();
                
                // Show floating status (smaller, non-blocking)
                showFloatingStatus(
                    `Recalculating ${specialFormulas.length} formulas...`,
                    `You can continue working. Highlighted cells will update.`,
                    0
                );
                
                // Pre-clear ALL special formula caches
                console.log(' Pre-clearing special formula caches...');
                for (const period of detectedPeriods) {
                    try {
                        await Excel.run(async (context) => {
                            const sheet = context.workbook.worksheets.getActiveWorksheet();
                            const tempRange = sheet.getRange('ZZ9997');
                            const clearCmd = `SPECIAL:ALL:${period}`;
                            tempRange.formulas = [[`=XAVI.BALANCE("__CLEARCACHE__","${clearCmd}","")`]];
                            await context.sync();
                            await new Promise(r => setTimeout(r, 200));
                            tempRange.clear();
                            await context.sync();
                        });
                    } catch (e) {
                        console.warn(`Cache clear failed for ${period}:`, e.message);
                    }
                }
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Helper function to wait for a cell to resolve
                async function waitForCellToResolve(row, col, maxWaitMs = 300000) {
                    const pollInterval = 2000;
                    const startTime = Date.now();
                    
                    while (Date.now() - startTime < maxWaitMs) {
                        let cellValue = null;
                        
                        await Excel.run(async (context) => {
                            const sheet = context.workbook.worksheets.getActiveWorksheet();
                            const usedRange = sheet.getUsedRange();
                            const cell = usedRange.getCell(row, col);
                            cell.load("values");
                            await context.sync();
                            cellValue = cell.values[0][0];
                        });
                        
                        const valueStr = String(cellValue || '');
                        const isResolved = valueStr !== '' && 
                                          !valueStr.includes('BUSY') &&
                                          !valueStr.includes('CALC') &&
                                          cellValue !== null;
                        
                        if (isResolved) {
                            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                            return { resolved: true, value: cellValue, elapsed };
                        }
                        
                        await new Promise(r => setTimeout(r, pollInterval));
                    }
                    
                    return { resolved: false, value: null, elapsed: maxWaitMs / 1000 };
                }
                
                // Helper to format period for display
                const formatPeriodDisplay = (resolvedPeriod) => {
                    const monthMap = {
                        'Jan': 'January', 'Feb': 'February', 'Mar': 'March', 'Apr': 'April',
                        'May': 'May', 'Jun': 'June', 'Jul': 'July', 'Aug': 'August',
                        'Sep': 'September', 'Oct': 'October', 'Nov': 'November', 'Dec': 'December'
                    };
                    const periodParts = resolvedPeriod.match(/^(\w+)\s+(\d{4})$/);
                    if (periodParts) {
                        const fullMonth = monthMap[periodParts[1]] || periodParts[1];
                        return `${fullMonth} ${periodParts[2]}`;
                    }
                    return resolvedPeriod;
                };
                
                // Process formulas ONE AT A TIME
                let successCount = 0;
                let errorCount = 0;
                
                for (let i = 0; i < specialFormulas.length; i++) {
                    const { row, col, formula, type, rawPeriod, resolvedPeriod } = specialFormulas[i];
                    const progress = Math.round((i / specialFormulas.length) * 100);
                    
                    const periodDisplay = formatPeriodDisplay(resolvedPeriod);
                    
                    // Set max wait time and message based on type
                    let maxWaitTime = 300000; // 5 minutes default
                    let typeLabel = type;
                    if (type === 'NETINCOME') {
                        typeLabel = 'Net Income';
                        maxWaitTime = 120000; // 2 minutes
                    } else if (type === 'RETAINEDEARNINGS') {
                        typeLabel = 'Retained Earnings';
                        maxWaitTime = 300000; // 5 minutes
                    } else if (type === 'CTA') {
                        typeLabel = 'CTA';
                        maxWaitTime = 300000; // 5 minutes
                    }
                    
                    // Update floating status
                    updateFloatingStatus(
                        `${typeLabel} (${i + 1}/${specialFormulas.length})`,
                        `${periodDisplay}`,
                        progress
                    );
                    console.log(` Processing ${type} for ${periodDisplay}...`);
                    
                    // Clear cache for THIS specific formula (use resolved period for cache key)
                    const cacheKeyPeriod = resolvedPeriod.match(/^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4}$/i) 
                        ? resolvedPeriod : rawPeriod;
                    try {
                        await Excel.run(async (context) => {
                            const sheet = context.workbook.worksheets.getActiveWorksheet();
                            const tempRange = sheet.getRange('ZZ9998');
                            const clearCmd = `SPECIAL:${type}:${cacheKeyPeriod}`;
                            tempRange.formulas = [[`=XAVI.BALANCE("__CLEARCACHE__","${clearCmd}","")`]];
                            await context.sync();
                            await new Promise(r => setTimeout(r, 300));
                            tempRange.clear();
                            await context.sync();
                        });
                    } catch (e) {
                        console.warn(`Cache clear failed for ${type}:${periodDisplay}:`, e.message);
                    }
                    
                    await new Promise(r => setTimeout(r, 200));
                    
                    // Trigger formula recalculation
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const usedRange = sheet.getUsedRange();
                        const cell = usedRange.getCell(row, col);
                        cell.formulas = [[formula]];
                        await context.sync();
                        cell.calculate();
                        await context.sync();
                    });
                    
                    // Wait for resolution
                    const result = await waitForCellToResolve(row, col, maxWaitTime);
                    
                    // Remove highlight from this cell (clear fill)
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const usedRange = sheet.getUsedRange();
                        const cell = usedRange.getCell(row, col);
                        cell.format.fill.clear();
                        await context.sync();
                    });
                    
                    if (result.resolved) {
                        const valueDisplay = typeof result.value === 'number' 
                            ? result.value.toLocaleString('en-US', { style: 'currency', currency: 'USD' })
                            : String(result.value);
                        console.log(`    ${type} [${periodDisplay}] = ${valueDisplay} (${result.elapsed}s)`);
                        successCount++;
                    } else {
                        console.log(`    ${type} [${periodDisplay}] TIMEOUT after ${result.elapsed}s`);
                        errorCount++;
                    }
                    
                    // Brief pause before next
                    await new Promise(r => setTimeout(r, 500));
                }
                
                const elapsed = ((Date.now() - start) / 1000).toFixed(1);
                
                // Hide floating status
                hideFloatingStatus();
                
                // Show result in status area
                if (errorCount === 0) {
                    statusEl.innerHTML = `
                        <div style="background: #d1fae5; padding: 12px; border-radius: 8px; margin-top: 10px;">
                            <strong style="color: #059669; font-size: 14px;"> Recalculation Complete!</strong><br>
                            <span style="font-size: 12px; color: #047857;">
                                ${successCount} formula(s) updated in ${elapsed}s
                            </span>
                        </div>
                    `;
                } else {
                    statusEl.innerHTML = `
                        <div style="background: #fef3c7; padding: 12px; border-radius: 8px; margin-top: 10px;">
                            <strong style="color: #b45309; font-size: 14px;"> Completed with Issues</strong><br>
                            <span style="font-size: 12px; color: #92400e;">
                                ${successCount} succeeded, ${errorCount} timed out in ${elapsed}s<br>
                                Timed out cells may show #TIMEOUT# - try again or check connection.
                            </span>
                        </div>
                    `;
                }
                
                setTimeout(() => { statusEl.textContent = ''; }, 15000);
                
            } catch (error) {
                console.error('Error recalculating special formulas:', error);
                hideLoading();
                hideFloatingStatus();
                
                // Clear any remaining highlights on error
                try {
                    await Excel.run(async (context) => {
                        const sheet = context.workbook.worksheets.getActiveWorksheet();
                        const usedRange = sheet.getUsedRange();
                        usedRange.load("formulas, rowCount, columnCount");
                        await context.sync();
                        
                        const formulas = usedRange.formulas;
                        for (let row = 0; row < usedRange.rowCount; row++) {
                            for (let col = 0; col < usedRange.columnCount; col++) {
                                const formula = formulas[row][col];
                                if (typeof formula === 'string' && 
                                    (formula.toUpperCase().includes('XAVI.RETAINEDEARNINGS') ||
                                     formula.toUpperCase().includes('XAVI.NETINCOME') ||
                                     formula.toUpperCase().includes('XAVI.CTA'))) {
                                    const cell = usedRange.getCell(row, col);
                                    cell.format.fill.clear();
                                }
                            }
                        }
                        await context.sync();
                    });
                } catch (e) {
                    // Ignore cleanup errors
                }
                
                statusEl.innerHTML = `
                    <div style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #dc2626;"> Error</strong><br>
                        <span style="font-size: 12px; color: #991b1b;">${error.message}</span>
                    </div>
                `;
                
                setTimeout(() => { statusEl.textContent = ''; }, 8000);
            } finally {
                btn.disabled = false;
            }
        }

        async function refreshSelected() {
            const statusEl = document.getElementById('refreshStatus');
            const btn = event.target;
            
            try {
                btn.disabled = true;
                
                showLoading('Refresh Selected', 'Analyzing selected cells...', 10);
                
                await Excel.run(async (context) => {
                    const range = context.workbook.getSelectedRange();
                    // Load both formulas AND values - values give us the resolved cell references
                    range.load('address, formulas, values, rowCount, columnCount');
                    await context.sync();
                    
                    updateLoading(`Parsing ${range.address}...`, 20);
                    
                    // Strategy: We need to get the RESOLVED values (account numbers and periods)
                    // The formulas use cell references, so we need to evaluate them
                    // We'll use a different approach: look at each cell that has an XAVI.BALANCE formula
                    // and extract the account/period by evaluating the referenced cells
                    
                    const itemsToClear = [];
                    const formulas = range.formulas;
                    const values = range.values;
                    
                    // Check if any cell contains XAVI.BALANCE formula
                    let formulaCount = 0;
                    const cellsWithFormulas = [];
                    
                    for (let r = 0; r < range.rowCount; r++) {
                        for (let c = 0; c < range.columnCount; c++) {
                            const formula = formulas[r][c];
                            if (formula && typeof formula === 'string' && formula.toUpperCase().includes('XAVI.BALANCE')) {
                                formulaCount++;
                                cellsWithFormulas.push({ row: r, col: c, formula });
                            }
                        }
                    }
                    
                    console.log(` Found ${formulaCount} XAVI.BALANCE formulas in selection`);
                    
                    if (formulaCount === 0) {
                        hideLoading();
                        statusEl.innerHTML = `<div style="background: #fef3c7; padding: 10px; border-radius: 6px;"><strong style="color: #d97706;"> No XAVI.BALANCE formulas found in selection</strong></div>`;
                        setTimeout(() => statusEl.textContent = '', 5000);
                        return;
                    }
                    
                    updateLoading(`Resolving cell references for ${formulaCount} formulas...`, 30);
                    
                    // For each formula, we need to resolve the cell references
                    // Parse the formula to extract cell references, then get their values
                    for (const cell of cellsWithFormulas) {
                        const formula = cell.formula;
                        
                        // Extract all cell references from the formula
                        // Pattern matches: $A$1, A1, $A1, A$1, etc.
                        const cellRefPattern = /\$?[A-Z]+\$?\d+/gi;
                        const refs = formula.match(cellRefPattern);
                        
                        if (refs && refs.length >= 2) {
                            // First ref is account, second is fromPeriod (third is toPeriod, usually same)
                            try {
                                const accountRef = refs[0];
                                const periodRef = refs[1];
                                
                                // Get the values of these cells
                                const accountCell = context.workbook.worksheets.getActiveWorksheet().getRange(accountRef);
                                const periodCell = context.workbook.worksheets.getActiveWorksheet().getRange(periodRef);
                                accountCell.load('values');
                                periodCell.load('values');
                                await context.sync();
                                
                                const account = String(accountCell.values[0][0]).trim();
                                let period = periodCell.values[0][0];
                                
                                // Convert date to "Mon YYYY" format
                                // Excel stores dates as serial numbers (days since Jan 1, 1900)
                                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                                
                                if (typeof period === 'number' && period > 1000) {
                                    // Excel serial number - convert to JS date
                                    // Excel epoch is Jan 1, 1900, JS epoch is Jan 1, 1970
                                    // Excel serial 1 = Jan 1, 1900
                                    const excelEpoch = new Date(1900, 0, 1);
                                    const d = new Date(excelEpoch.getTime() + (period - 2) * 24 * 60 * 60 * 1000);
                                    period = `${months[d.getMonth()]} ${d.getFullYear()}`;
                                } else if (period instanceof Date) {
                                    period = `${months[period.getMonth()]} ${period.getFullYear()}`;
                                } else if (typeof period === 'string') {
                                    // Already a string like "Jan 2025" - use as-is
                                    period = period.trim();
                } else {
                                    period = String(period).trim();
                                }
                                
                                if (account && period) {
                                    itemsToClear.push({ account, period });
                                    console.log(`    Resolved: ${account} / ${period}`);
                                }
                            } catch (e) {
                                console.warn(`    Could not resolve refs for formula: ${formula}`, e);
                            }
                        }
                    }
                    
                    console.log(`   Items to clear: ${itemsToClear.length}`);
                    
                    if (itemsToClear.length === 0) {
                        hideLoading();
                        statusEl.innerHTML = `<div style="background: #fef3c7; padding: 10px; border-radius: 6px;"><strong style="color: #d97706;"> Could not resolve cell references</strong></div>`;
                        setTimeout(() => statusEl.textContent = '', 5000);
                        return;
                    }
                    
                    updateLoading(`Clearing cache for ${itemsToClear.length} items...`, 50);
                    
                    // SELECTIVE cache clear - clear from localStorage directly
                    // Also set invalidation signal for functions.js to check
                    let clearedCount = 0;
                    try {
                        const STORAGE_KEY = 'netsuite_balance_cache';
                        const stored = localStorage.getItem(STORAGE_KEY);
                        if (stored) {
                            const balanceData = JSON.parse(stored);
                            let modified = false;
                            
                            for (const item of itemsToClear) {
                                const acct = String(item.account);
                                if (balanceData[acct] && balanceData[acct][item.period] !== undefined) {
                                    delete balanceData[acct][item.period];
                                    clearedCount++;
                                    modified = true;
                                    console.log(`    Cleared localStorage: ${acct}/${item.period}`);
                                }
                            }
                            
                            if (modified) {
                                localStorage.setItem(STORAGE_KEY, JSON.stringify(balanceData));
                                console.log(`    Updated localStorage (removed ${clearedCount} entries)`);
                            }
                        }
                        
                        // Set cache invalidation signal - functions.js will check this
                        // and clear its in-memory caches when it sees items to invalidate
                        const invalidateKey = 'netsuite_cache_invalidate';
                        const invalidateItems = itemsToClear.map(i => `${i.account}:${i.period}`);
                        localStorage.setItem(invalidateKey, JSON.stringify({
                            items: invalidateItems,
                            timestamp: Date.now()
                        }));
                        console.log(`    Set invalidation signal for ${invalidateItems.length} items`);
                        
                    } catch (e) {
                        console.warn('Cache clear error:', e);
                    }
                    
                    console.log(` Cleared ${clearedCount} localStorage entries for refresh`)
                    
                    // CRITICAL: Call XAVI.BALANCE("__CLEARCACHE__", "items", "") in the custom functions runtime
                    // This clears cache in the SAME context as BALANCE (different from taskpane!)
                    // Pass specific items as "60032:May 2025,60032:Jun 2025" format (simple, no JSON escaping)
                    updateLoading('Clearing in-memory cache...', 60);
                    try {
                        // Build simple comma-separated list: "60032:May 2025,60032:Jun 2025"
                        const itemsList = itemsToClear.map(i => `${i.account}:${i.period}`).join(',');
                        console.log(` Calling __CLEARCACHE__ for ${itemsToClear.length} items...`);
                        console.log(`   Items: ${itemsList}`);
                        
                        // Use a temporary cell to evaluate the BALANCE function with __CLEARCACHE__ command
                        const tempSheet = context.workbook.worksheets.getActiveWorksheet();
                        const tempRange = tempSheet.getRange('XFD1'); // Far corner, unlikely to be used
                        
                        // Pass specific items - this clears ONLY these items from functions' cache
                        tempRange.formulas = [[`=XAVI.BALANCE("__CLEARCACHE__","${itemsList}","")`]];
                    await context.sync();
                    
                        // Wait for custom function to execute
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        
                        // Load and read the result
                        tempRange.load('values');
                        await context.sync();
                        
                        const result = tempRange.values[0][0];
                        console.log('    __CLEARCACHE__ result:', result, '(items cleared)');
                        
                        // Clear the temp cell
                        tempRange.clear();
                    await context.sync();
                    
                    } catch (clearError) {
                        console.warn('    __CLEARCACHE__ call failed:', clearError.message);
                        // Continue anyway - localStorage was cleared from taskpane context
                    }
                    
                    updateLoading(`Recalculating ${formulaCount} formulas...`, 70);
                    
                    // Trigger recalc by re-setting formulas
                    range.formulas = formulas;
                    await context.sync();
                    
                    updateLoading('Fetching from NetSuite...', 85);
                    
                    // Wait for batching to complete
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    
                    updateLoading('Complete!', 100);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    hideLoading();
                    
                    statusEl.innerHTML = `<div style="background: #d1fae5; padding: 10px; border-radius: 6px;"><strong style="color: #059669;"> Refreshed ${formulaCount} formulas from NetSuite!</strong></div>`;
                    
                    setTimeout(() => {
                        statusEl.textContent = '';
                    }, 5000);
                });
                
            } catch (error) {
                console.error('Error refreshing selection:', error);
                hideLoading();
                
                statusEl.innerHTML = `<div style="background: #fee2e2; padding: 10px; border-radius: 6px;"><strong style="color: #dc2626;"> Error:</strong> ${error.message}</div>`;
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 8000);
            } finally {
                btn.disabled = false;
            }
        }

        async function drillDownTransactions() {
            const statusEl = document.getElementById('drillStatus');
            const btn = event.target;
            
            try {
                btn.disabled = true;
                btn.textContent = 'Loading...';
                statusEl.textContent = 'Analyzing selected cell...';
                statusEl.style.color = '#0284c7';
                
                console.log('=== DRILL-DOWN DEBUG START ===');
                console.log('SERVER_URL:', SERVER_URL);
                
                await Excel.run(async (context) => {
                    // Get the selected cell
                    const range = context.workbook.getSelectedRange();
                    range.load(['formulas', 'values', 'address']);
                    
                    await context.sync();
                    
                    const formula = range.formulas[0][0];
                    const address = range.address;
                    
                    console.log('Selected cell:', address);
                    console.log('Formula:', formula);
                    console.log('Value:', range.values[0][0]);
                    
                    // Check if it's an XAVI.BALANCE formula
                    if (!formula || !formula.toUpperCase().includes('XAVI.BALANCE')) {
                        statusEl.textContent = ' Please select a cell with an XAVI.BALANCE formula';
                        statusEl.style.color = '#dc2626';
                        setTimeout(() => { statusEl.textContent = ''; }, 5000);
                        return;
                    }
                    
                    // Parse the formula to extract cell references
                    // Formula format: =XAVI.BALANCE(account, fromPeriod, toPeriod, subsidiary, department, location, class)
                    const cellRefs = parseFormulaCellRefs(formula);
                    console.log('Cell references from formula:', cellRefs);
                    
                    // Now get the actual VALUES from those cells
                    const params = await resolveFormulaParams(context, cellRefs);
                    console.log('Resolved params:', params);
                    
                    if (!params || !params.account || !params.period) {
                        console.error('Failed to parse formula. Params:', params);
                        statusEl.textContent = ' Could not parse formula parameters';
                        statusEl.style.color = '#dc2626';
                        setTimeout(() => { statusEl.textContent = ''; }, 5000);
                        return;
                    }
                    
                    console.log('Using account:', params.account, 'period:', params.period);
                    
                    statusEl.textContent = 'Fetching transactions from NetSuite...';
                    
                    // Build query string
                    const queryParams = new URLSearchParams({
                        account: params.account,
                        period: params.period
                    });
                    
                    if (params.subsidiary) queryParams.append('subsidiary', params.subsidiary);
                    if (params.department) queryParams.append('department', params.department);
                    if (params.location) queryParams.append('location', params.location);
                    if (params.class) queryParams.append('class', params.class);
                    
                    const fetchUrl = `${SERVER_URL}/transactions?${queryParams}`;
                    console.log('Fetching from:', fetchUrl);
                    
                    // Fetch transactions from backend
                    const response = await fetch(fetchUrl);
                    
                    console.log('Response status:', response.status);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('API error response:', errorText);
                        throw new Error(`API error: ${response.status} - ${errorText}`);
                    }
                    
                    const data = await response.json();
                    console.log('API response:', data);
                    
                    const transactions = data.transactions;
                    console.log('Transactions count:', transactions ? transactions.length : 0);
                    
                    if (!transactions || transactions.length === 0) {
                        console.warn('No transactions found');
                        statusEl.textContent = ' No transactions found for this period';
                        statusEl.style.color = '#059669';
                        setTimeout(() => { statusEl.textContent = ''; }, 5000);
                        return;
                    }
                    
                    console.log('Creating drill-down sheet with', transactions.length, 'transaction(s)');
                    
                    // Create new sheet with transaction details
                    await createDrillDownSheet(context, transactions, params);
                    
                    statusEl.textContent = ` Loaded ${transactions.length} transaction(s)!`;
                    statusEl.style.color = '#059669';
                    
                    setTimeout(() => {
                        statusEl.textContent = '';
                    }, 3000);
                });
                
            } catch (error) {
                console.error('=== DRILL-DOWN ERROR ===');
                console.error('Error type:', error.constructor.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                console.error('Full error:', error);
                
                statusEl.textContent = ' Error: ' + error.message;
                statusEl.style.color = '#dc2626';
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 5000);
            } finally {
                console.log('=== DRILL-DOWN DEBUG END ===');
                btn.disabled = false;
                btn.textContent = 'View Transactions';
            }
        }

        function parseFormulaCellRefs(formula) {
            try {
                // Extract content between parentheses
                const match = formula.match(/XAVI\.BALANCE\s*\((.*)\)/i);
                if (!match) return null;
                
                const paramsStr = match[1];
                
                // Split by comma, but be careful with quotes and nested functions
                const params = [];
                let current = '';
                let inQuotes = false;
                let parenDepth = 0;
                
                for (let i = 0; i < paramsStr.length; i++) {
                    const char = paramsStr[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                        current += char;
                    } else if (char === '(' && !inQuotes) {
                        parenDepth++;
                        current += char;
                    } else if (char === ')' && !inQuotes) {
                        parenDepth--;
                        current += char;
                    } else if (char === ',' && !inQuotes && parenDepth === 0) {
                        params.push(current.trim());
                        current = '';
                } else {
                        current += char;
                    }
                }
                
                if (current.trim()) {
                    params.push(current.trim());
                }
                
                // Return cell references or literal values as-is
                return {
                    accountRef: params[0] || '',
                    fromPeriodRef: params[1] || '',
                    toPeriodRef: params[2] || '',
                    subsidiaryRef: params[3] || '',
                    departmentRef: params[4] || '',
                    locationRef: params[5] || '',
                    classRef: params[6] || ''
                };
                
            } catch (error) {
                console.error('Error parsing formula:', error);
                return null;
            }
        }

        async function resolveFormulaParams(context, cellRefs) {
            try {
                // Helper to clean up a parameter (remove quotes, handle empty)
                const cleanParam = (p) => {
                    if (!p || p === '""' || p === '') return '';
                    // Remove surrounding quotes
                    return p.replace(/^["']|["']$/g, '');
                };
                
                // Helper to check if a string is a cell reference (like A1, $A$1, H$3, etc.)
                const isCellRef = (str) => {
                    return /^[\$]?[A-Z]+[\$]?\d+$/.test(str);
                };
                
                // Helper to get value from cell reference or return literal value
                const getValue = async (ref) => {
                    if (!ref || ref === '""' || ref === '') return '';
                    
                    const cleaned = cleanParam(ref);
                    
                    // If it's a cell reference, get the value from that cell
                    if (isCellRef(cleaned)) {
                        try {
                            const sheet = context.workbook.worksheets.getActiveWorksheet();
                            const refRange = sheet.getRange(cleaned);
                            refRange.load('values');
                            await context.sync();
                            
                            const value = refRange.values[0][0];
                            console.log(`  Resolved ${cleaned} to:`, value);
                            return String(value || '');
                        } catch (e) {
                            console.warn(`Could not resolve cell reference ${cleaned}:`, e);
                            return '';
                        }
                    }
                    
                    // Otherwise return the literal value
                    return cleaned;
                };
                
                // Helper to convert Excel date serial to period name
                const convertToPeriodName = (value) => {
                    if (!value) return '';
                    
                    // If it's already a string like "Jan 2024", return as-is
                    if (typeof value === 'string' && /^[A-Za-z]{3}\s+\d{4}$/.test(value.trim())) {
                        return value.trim();
                    }
                    
                    // If it's a number, it might be an Excel date serial
                    const num = Number(value);
                    if (!isNaN(num) && num > 40000 && num < 60000) {
                        // Excel date serial: convert to JS Date
                        // Excel epoch is Dec 30, 1899 (with the 1900 leap year bug)
                        const excelEpoch = new Date(1899, 11, 30);
                        const jsDate = new Date(excelEpoch.getTime() + num * 24 * 60 * 60 * 1000);
                        
                        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                                           'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                        const periodName = `${monthNames[jsDate.getMonth()]} ${jsDate.getFullYear()}`;
                        console.log(`   Converted Excel date ${value} to period: ${periodName}`);
                        return periodName;
                    }
                    
                    // Otherwise return as-is
                    return String(value);
                };
                
                // Resolve all parameters
                const account = await getValue(cellRefs.accountRef);
                const fromPeriodRaw = await getValue(cellRefs.fromPeriodRef);
                const toPeriodRaw = await getValue(cellRefs.toPeriodRef);
                const subsidiary = await getValue(cellRefs.subsidiaryRef);
                const department = await getValue(cellRefs.departmentRef);
                const location = await getValue(cellRefs.locationRef);
                const classId = await getValue(cellRefs.classRef);
                
                // Convert periods if they're Excel date serials
                const fromPeriod = convertToPeriodName(fromPeriodRaw);
                const toPeriod = convertToPeriodName(toPeriodRaw);
                
                return {
                    account: account,
                    period: fromPeriod, // Use fromPeriod as the drill-down period
                    subsidiary: subsidiary,
                    department: department,
                    location: location,
                    class: classId
                };
                
            } catch (error) {
                console.error('Error resolving formula params:', error);
                return null;
            }
        }

        async function createDrillDownSheet(context, transactions, params) {
            // Create or get drill-down sheet
            const sheetName = `DrillDown_${params.account}`;
            
            let drillSheet;
            try {
                drillSheet = context.workbook.worksheets.getItem(sheetName);
                drillSheet.delete();
                await context.sync();
            } catch (e) {
                // Sheet doesn't exist, that's fine
            }
            
            drillSheet = context.workbook.worksheets.add(sheetName);
            drillSheet.activate();
            
            // Add header
            drillSheet.getRange('A1').values = [['TRANSACTION DRILL-DOWN']];
            drillSheet.getRange('A1').format.font.bold = true;
            drillSheet.getRange('A1').format.font.size = 14;
            
            drillSheet.getRange('A2').values = [[`Account: ${params.account} | Period: ${params.period}`]];
            drillSheet.getRange('A2').format.font.bold = true;
            
            // Add column headers
            const headers = [
                ['Date', 'Type', 'Number', 'Entity', 'Memo', 'Debit', 'Credit', 'Net Amount']
            ];
            drillSheet.getRange('A4:H4').values = headers;
            drillSheet.getRange('A4:H4').format.font.bold = true;
            drillSheet.getRange('A4:H4').format.fill.color = '#667eea';
            drillSheet.getRange('A4:H4').format.font.color = 'white';
            
            // Add transaction data (without NetSuite Link column)
            const dataRows = transactions.map(txn => [
                txn.transaction_date || '',
                txn.transaction_type || '',
                txn.transaction_number || '',
                txn.entity_name || '',
                txn.memo || '',
                txn.debit ? parseFloat(txn.debit) : 0,
                txn.credit ? parseFloat(txn.credit) : 0,
                txn.net_amount ? parseFloat(txn.net_amount) : 0
            ]);
            
            const dataRange = drillSheet.getRange(`A5:H${4 + dataRows.length}`);
            dataRange.values = dataRows;
            
            // Format numbers as currency
            drillSheet.getRange(`F5:H${4 + dataRows.length}`).numberFormat = [['$#,##0.00']];
            
            // Add hyperlinks to NetSuite URLs
            for (let i = 0; i < transactions.length; i++) {
                const txn = transactions[i];
                const row = 5 + i;
                
                // Add hyperlink for transaction number
                const linkCell = drillSheet.getRange(`C${row}`);
                const hyperlink = {
                    address: txn.netsuite_url,
                    textToDisplay: txn.transaction_number
                };
                linkCell.hyperlink = hyperlink;
                linkCell.format.font.color = '#0ea5e9';
                linkCell.format.font.underline = 'Single';
            }
            
            // Auto-fit columns
            drillSheet.getRange('A:H').format.autofitColumns();
            
            // Add summary at bottom
            const summaryRow = 5 + dataRows.length + 2;
            drillSheet.getRange(`A${summaryRow}`).values = [[`Total Transactions: ${transactions.length}`]];
            drillSheet.getRange(`A${summaryRow}`).format.font.bold = true;
            
            const totalDebit = dataRows.reduce((sum, row) => sum + row[5], 0);
            const totalCredit = dataRows.reduce((sum, row) => sum + row[6], 0);
            const totalNet = dataRows.reduce((sum, row) => sum + row[7], 0);
            
            drillSheet.getRange(`E${summaryRow}`).values = [['Totals:']];
            drillSheet.getRange(`F${summaryRow}`).values = [[totalDebit]];
            drillSheet.getRange(`G${summaryRow}`).values = [[totalCredit]];
            drillSheet.getRange(`H${summaryRow}`).values = [[totalNet]];
            drillSheet.getRange(`E${summaryRow}:H${summaryRow}`).format.font.bold = true;
            drillSheet.getRange(`F${summaryRow}:H${summaryRow}`).numberFormat = [['$#,##0.00']];
            
            await context.sync();
        }

        // ==========================================================================
        // CONTEXT MENU HANDLER (called when right-clicking and selecting "View Transactions")
        // ==========================================================================
        async function searchAccounts() {
            const statusEl = document.getElementById('searchStatus');
            const inputEl = document.getElementById('accountSearchInput');
            const btn = event.target;
            
            try {
                const pattern = inputEl.value.trim();
                
                if (!pattern) {
                    statusEl.textContent = ' Please enter a search pattern (e.g., 4* or 42*)';
                    statusEl.style.color = '#dc2626';
                    setTimeout(() => { statusEl.textContent = ''; }, 3000);
                    return;
                }
                
                btn.disabled = true;
                btn.textContent = 'Searching...';
                
                showLoading('Account Search', `Searching for "${pattern}"...`, 20);
                
                console.log('=== ACCOUNT SEARCH START ===');
                console.log('Pattern:', pattern);
                
                // Call backend API
                const url = `${SERVER_URL}/accounts/search?pattern=${encodeURIComponent(pattern)}`;
                console.log('API URL:', url);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API error:', errorText);
                    throw new Error(`API error: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Search results:', data);
                
                const accounts = data.accounts || [];
                
                if (accounts.length === 0) {
                    hideLoading();
                    statusEl.textContent = ` No accounts found matching "${pattern}"`;
                    statusEl.style.color = '#059669';
                    setTimeout(() => { statusEl.textContent = ''; }, 5000);
                    return;
                }
                
                console.log(`Found ${accounts.length} accounts, creating sheet...`);
                
                updateLoading(`Inserting ${accounts.length} accounts...`, 70);
                
                // Create results sheet
                await Excel.run(async (context) => {
                    await createAccountSearchSheet(context, accounts, pattern);
                });
                
                updateLoading('Complete!', 100);
                await new Promise(resolve => setTimeout(resolve, 500));
                hideLoading();
                
                statusEl.innerHTML = `<div style="background: #d1fae5; padding: 10px; border-radius: 6px;"><strong style="color: #059669;"> Inserted ${accounts.length} accounts!</strong></div>`;
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 5000);
                
                console.log('=== ACCOUNT SEARCH COMPLETE ===');
                
            } catch (error) {
                console.error('=== ACCOUNT SEARCH ERROR ===');
                console.error('Error:', error);
                hideLoading();
                
                statusEl.innerHTML = `<div style="background: #fee2e2; padding: 10px; border-radius: 6px;"><strong style="color: #dc2626;"> Error:</strong> ${error.message}</div>`;
                
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 8000);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Bulk Add Accounts';
            }
        }

        async function createAccountSearchSheet(context, accounts, pattern) {
            // INSERT AT CURSOR POSITION (not new sheet!)
            const sheet = context.workbook.worksheets.getActiveWorksheet();
            const range = context.workbook.getSelectedRange();
            range.load(['address', 'rowIndex', 'columnIndex']);
            await context.sync();
            
            console.log(`Inserting ${accounts.length} accounts at ${range.address}`);
            
            // Prepare data WITHOUT headers (just the data)
            // Order: Type, Number, Name (matches Guide Me wizard)
            const dataRows = accounts.map(acc => [
                acc.accttype || '',
                acc.accountnumber || '',
                acc.accountname || ''
            ]);
            
            // Get the range starting at cursor position
            const targetRange = sheet.getRangeByIndexes(
                range.rowIndex,
                range.columnIndex,
                dataRows.length,
                3
            );
            
            // Insert data
            targetRange.values = dataRows;
            
            // Auto-fit columns
            targetRange.format.autofitColumns();
            
            await context.sync();
            
            console.log(`Inserted ${accounts.length} accounts at cursor position`);
        }

        async function drillDownFromContextMenu(event) {
            console.log('=== CONTEXT MENU DRILL-DOWN START ===');
            
            try {
                // Use the same drill-down logic as the button
                await drillDownTransactions();
                
            } catch (error) {
                console.error('=== CONTEXT MENU DRILL-DOWN ERROR ===');
                console.error('Error:', error);
            } finally {
                // Signal to Excel that the command is complete
                if (event && event.completed) {
                    event.completed();
                }
            }
        }

        // Make function globally available for ExecuteFunction action
        window.drillDownFromContextMenu = drillDownFromContextMenu;
        
        // Log that function is available
        console.log(' drillDownFromContextMenu registered on window object');
        console.log('Function type:', typeof window.drillDownFromContextMenu);
    </script>
</body>
</html>
